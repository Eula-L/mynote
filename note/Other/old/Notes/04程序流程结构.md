---
title: 04程序流程结构
date: 2022-07-21T20:59:44Z
lastmod: 2022-09-11T18:06:38Z
---

# 04程序流程结构

　　05数组[^1]

## 4 程序流程结构

　　C/C++ 支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应功能
* 循环结构：依据条件是否满足，循环多次执行某段代码

### 4.1 选择结构

#### 4.1.1 if 语句

　　作用：执行满足条件的语句

　　if 语句的三种形式

* 单行格式 if 语句
* 多行格式 if 语句
* 多条件的 if 语句

1. 单行格式 if 语句：`if(条件){ 条件满足执行的语句 }`
   示例：

```C++
int main() {

  //选择结构-单行if语句
  //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印

  int score = 0;
  cout << "请输入一个分数：" << endl;
  cin >> score;

  cout << "您输入的分数为： " << score << endl;

  //if语句
  //注意事项，在if判断语句后面，不要加分号
  if (score > 600)
  {
    cout << "我考上了一本大学！！！" << endl;
  }

  system("pause");

  return 0;
}
```

> 注意：if 条件表达式后不要加分号

1. 多行格式 if 语句：`if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };`

　　示例：

```C++
int main() {

  int score = 0;

  cout << "请输入考试分数：" << endl;

  cin >> score;

  if (score > 600)
  {
    cout << "我考上了一本大学" << endl;
  }
  else
  {
    cout << "我未考上一本大学" << endl;
  }

  system("pause");

  return 0;
}
```

1. 多条件的 if 语句：`if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}`

　　示例：

```C++
int main() {

int score = 0;

cout << "请输入考试分数：" << endl;

cin >> score;

if (score > 600)
{
  cout << "我考上了一本大学" << endl;
}
else if (score > 500)
{
  cout << "我考上了二本大学" << endl;
}
else if (score > 400)
{
  cout << "我考上了三本大学" << endl;
}
else
{
  cout << "我未考上本科" << endl;
}

system("pause");

return 0;
}
```

　　 **嵌套 if 语句** ：在 if 语句中，可以嵌套使用 if 语句，达到更精确的条件判断

　　案例需求：

* 提示用户输入一个高考考试分数，根据分数做如下判断
* 分数如果大于 600 分视为考上一本，大于 500 分考上二本，大于 400 考上三本，其余视为未考上本科；
* 在一本分数中，如果大于 700 分，考入北大，大于 650 分，考入清华，大于 600 考入人大。

　　**示例：**

```c++
int main() {

  int score = 0;

  cout << "请输入考试分数：" << endl;

  cin >> score;

  if (score > 600)
  {
    cout << "我考上了一本大学" << endl;
    if (score > 700)
    {
      cout << "我考上了北大" << endl;
    }
    else if (score > 650)
    {
      cout << "我考上了清华" << endl;
    }
    else
    {
      cout << "我考上了人大" << endl;
    }
  
  }
  else if (score > 500)
  {
    cout << "我考上了二本大学" << endl;
  }
  else if (score > 400)
  {
    cout << "我考上了三本大学" << endl;
  }
  else
  {
    cout << "我未考上本科" << endl;
  }

  system("pause");

  return 0;
}
```

　　**练习案例：** 三只小猪称体重

　　有三只小猪 ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-QhWQp41I-1638452706982)(assets/三只小猪.jpg)]

#### 4.1.2 三目运算符

　　**作用：** 通过三目运算符实现简单的判断

　　 **语法：** `表达式1 ? 表达式2 ：表达式3`

　　**解释：**

　　如果表达式 1 的值为真，执行表达式 2，并返回表达式 2 的结果；

　　如果表达式 1 的值为假，执行表达式 3，并返回表达式 3 的结果。

　　**示例：**

```C++
int main() {

  int a = 10;
  int b = 20;
  int c = 0;

  c = a > b ? a : b;
  cout << "c = " << c << endl;

  //C++中三目运算符返回的是变量,可以继续赋值

  (a > b ? a : b) = 100;

  cout << "a = " << a << endl;
  cout << "b = " << b << endl;
  cout << "c = " << c << endl;

  system("pause");

  return 0;
}
```

> 总结：和 if 语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰

#### 4.1.3 switch 语句

　　**作用：**执行多条件分支语句

　　**语法：**

```C++
switch(表达式)

{

  case 结果1：执行语句;break;

  case 结果2：执行语句;break;

  ...

  default:执行语句;break;

}

```

　　**示例：**

```C++
int main() {

  //请给电影评分 
  //10 ~ 9   经典   
  // 8 ~ 7   非常好
  // 6 ~ 5   一般
  // 5分以下 烂片

  int score = 0;
  cout << "请给电影打分" << endl;
  cin >> score;

  switch (score)
  {
  case 10:
  case 9:
    cout << "经典" << endl;
    break;
  case 8:
    cout << "非常好" << endl;
    break;
  case 7:
  case 6:
    cout << "一般" << endl;
    break;
  default:
    cout << "烂片" << endl;
    break;
  }

  system("pause");

  return 0;
}
```

> 注意 1：switch 语句中表达式类型只能是整型或者字符型

> 注意 2：case 里如果没有 break，那么程序会一直向下执行

> 总结：与 if 语句比，对于多条件判断时，switch 的结构清晰，执行效率高，缺点是 switch 不可以判断区间

### 4.2 循环结构

#### 4.2.1 while 循环语句

　　**作用：**满足循环条件，执行循环语句

　　**语法：**​`​ while(循环条件){ 循环语句 }`

　　 **解释：** ==只要循环条件的结果为真，就执行循环语句==

　　[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hSPtIcN5-1638452706983)(assets/clip_image002-1541668640382-20211108124630-ykcs5bd.png)]

　　**示例：**

```C++
int main() {

  int num = 0;
  while (num < 10)
  {
    cout << "num = " << num << endl;
    num++;
  }

  system("pause");

  return 0;
}
```

> 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环

　　 **while 循环练习案例：** ==猜数字==

　　**案例描述：**系统随机生成一个 1 到 100 之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。

　　[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6JhdZ35f-1638452706984)(assets/猜数字.jpg)]

#### 4.2.2 do...while 循环语句

　　**作用：** 满足循环条件，执行循环语句

　　**语法：** `do{ 循环语句 } while(循环条件);`

　　**注意：**与 while 的区别在于 ==do...while 会先执行一次循环语句==，再判断循环条件

　　[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZPLxSBcM-1638452706985)(assets/clip_image002-1541671163478-20211108124715-zbl7w00.png)]

　　**示例：**

```C++
int main() {

  int num = 0;

  do
  {
    cout << num << endl;
    num++;

  } while (num < 10);

  system("pause");

  return 0;
}
```

> 总结：与 while 循环区别在于，do...while 先执行一次循环语句，再判断循环条件

　　**练习案例：水仙花数**

　　**案例描述：**水仙花数是指一个 3 位数，它的每个位上的数字的 3 次幂之和等于它本身

　　例如：1^3 + 5^3+ 3^3 = 153

　　请利用 do...while 语句，求出所有 3 位数中的水仙花数

#### 4.2.3 for 循环语句

　　**作用：** 满足循环条件，执行循环语句

　　**语法：**​`​ for(起始表达式;条件表达式;末尾循环体) { 循环语句; }`

　　**示例：**

```C++
int main() {

  for (int i = 0; i < 10; i++)
  {
    cout << i << endl;
  }

  system("pause");

  return 0;
}
```

　　**详解：**

> 注意：for 循环中的表达式，要用分号进行分隔

> 总结：while , do...while, for 都是开发中常用的循环语句，for 循环结构比较清晰，比较常用

　　**练习案例：敲桌子**

　　案例描述：从 1 开始数到数字 100， 如果数字个位含有 7，或者数字十位含有 7，或者该数字是 7 的倍数，我们打印敲桌子，其余数字直接打印输出。

#### 4.2.4 嵌套循环

　　**作用：** 在循环体中再嵌套一层循环，解决一些实际问题

　　例如我们想在屏幕中打印如下图片，就需要利用嵌套循环

　　**示例：**

```C++
int main() {

  //外层循环执行1次，内层循环执行1轮
  for (int i = 0; i < 10; i++)
  {
    for (int j = 0; j < 10; j++)
    {
      cout << "*" << " ";
    }
    cout << endl;
  }

  system("pause");

  return 0;
}
```

　　**练习案例：**乘法口诀表

　　案例描述：利用嵌套循环，实现九九乘法表

### 4.3 跳转语句

#### 4.3.1 break 语句

　　**作用:** 用于跳出==选择结构==或者==循环结构==

　　break 使用的时机：

* 出现在 switch 条件语句中，作用是终止 case 并跳出 switch
* 出现在循环语句中，作用是跳出当前的循环语句
* 出现在嵌套循环中，跳出最近的内层循环语句

　　**示例 1：**

```C++
int main() {
  //1、在switch 语句中使用break
  cout << "请选择您挑战副本的难度：" << endl;
  cout << "1、普通" << endl;
  cout << "2、中等" << endl;
  cout << "3、困难" << endl;

  int num = 0;

  cin >> num;

  switch (num)
  {
  case 1:
    cout << "您选择的是普通难度" << endl;
    break;
  case 2:
    cout << "您选择的是中等难度" << endl;
    break;
  case 3:
    cout << "您选择的是困难难度" << endl;
    break;
  }

  system("pause");

  return 0;
}
```

　　**示例 2：**

```C++
int main() {
  //2、在循环语句中用break
  for (int i = 0; i < 10; i++)
  {
    if (i == 5)
    {
      break; //跳出循环语句
    }
    cout << i << endl;
  }

  system("pause");

  return 0;
}
```

　　**示例 3：**

```C++
int main() {
  //在嵌套循环语句中使用break，退出内层循环
  for (int i = 0; i < 10; i++)
  {
    for (int j = 0; j < 10; j++)
    {
      if (j == 5)
      {
        break;
      }
      cout << "*" << " ";
    }
    cout << endl;
  }

  system("pause");

  return 0;
}
```

#### 4.3.2 continue 语句

　　**作用：**在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环

　　**示例：**

```C++
int main() {

  for (int i = 0; i < 100; i++)
  {
    if (i % 2 == 0)
    {
      continue;
    }
    cout << i << endl;
  }

  system("pause");

  return 0;
}
```

> 注意：continue 并没有使整个循环终止，而 break 会跳出循环

#### 4.3.3 goto 语句

　　**作用：**可以无条件跳转语句

　　**语法：** `goto 标记;`

　　**解释：**如果标记的名称存在，执行到 goto 语句时，会跳转到标记的位置

　　**示例：**

```C++
int main() {

  cout << "1" << endl;

  goto FLAG;

  cout << "2" << endl;
  cout << "3" << endl;
  cout << "4" << endl;

  FLAG:

  cout << "5" << endl;

  system("pause");

  return 0;
}
```

> 注意：在程序中不建议使用 goto 语句，以免造成程序流程混乱

[^1]: # 05数组

    06字符串[^2]

    ### 5.1 概述

    所谓数组，就是一个集合，里面存放了相同类型的数据元素

    特点1：数组中的每个==数据元素都是相同的数据类型==

    特点2：数组是由==连续的内存==位置组成的

    ### 5.2 一维数组

    #### 5.2.1 一维数组定义方式

    一维数组定义的三种方式：

    1. `数据类型  数组名[ 数组长度 ];`
    2. `数据类型  数组名[ 数组长度 ] = { 值1，值2 ...};`
    3. `数据类型  数组名[ ] = { 值1，值2 ...};`

    示例

    ```C++
    int main() {

      //定义方式1
      //数据类型 数组名[元素个数];
      int score[10];

      //利用下标赋值
      score[0] = 100;
      score[1] = 99;
      score[2] = 85;

      //利用下标输出
      cout << score[0] << endl;
      cout << score[1] << endl;
      cout << score[2] << endl;

      //第二种定义方式
      //数据类型 数组名[元素个数] =  {值1，值2 ，值3 ...};
      //如果{}内不足10个数据，剩余数据用0补全
      int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 };

      //逐个输出
      //cout << score2[0] << endl;
      //cout << score2[1] << endl;

      //一个一个输出太麻烦，因此可以利用循环进行输出
      for (int i = 0; i < 10; i++)
      {
        cout << score2[i] << endl;
      }

      //定义方式3
      //数据类型 数组名[] =  {值1，值2 ，值3 ...};
      int score3[] = { 100,90,80,70,60,50,40,30,20,10 };

      for (int i = 0; i < 10; i++)
      {
        cout << score3[i] << endl;
      }

      system("pause");

      return 0;
    }
    ```
    > 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名
    >

    > 总结2：数组中下标是从0开始索引
    >

    #### 5.2.2 一维数组数组名

    一维数组名称的 **用途** ：

    1. 可以统计整个数组在内存中的长度
    2. 可以获取数组在内存中的首地址

    **示例：**

    ```C++
    int main() {

      //数组名用途
      //1、可以获取整个数组占用内存空间大小
      int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

      cout << "整个数组所占内存空间为： " << sizeof(arr) << endl;
      cout << "每个元素所占内存空间为： " << sizeof(arr[0]) << endl;
      cout << "数组的元素个数为： " << sizeof(arr) / sizeof(arr[0]) << endl;

      //2、可以通过数组名获取到数组首地址
      cout << "数组首地址为： " << (int)arr << endl;
      cout << "数组中第一个元素地址为： " << (int)&arr[0] << endl;
      cout << "数组中第二个元素地址为： " << (int)&arr[1] << endl;

      //arr = 100; 错误，数组名是常量，因此不可以赋值

      system("pause");

      return 0;
    }
    ```
    > 注意：数组名是常量，不可以赋值
    >

    > 总结1：直接打印数组名，可以查看数组所占内存的首地址
    >

    > 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小
    >

     **练习案例1** ：五只小猪称体重

    **案例描述：**

    在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250};

    找出并打印最重的小猪体重。

    **练习案例2：**数组元素逆置

    **案例描述：**请声明一个5个元素的数组，并且将元素逆置.

    (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);

    #### 5.2.3 冒泡排序

    **作用：** 最常用的排序算法，对数组内元素进行排序

    1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
    2. 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。
    3. 重复以上的步骤，每次比较次数-1，直到不需要比较

    **示例：** 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序

    ```C++
    int main() {

      int arr[9] = { 4,2,8,0,5,7,1,3,9 };

      for (int i = 0; i < 9 - 1; i++)
      {
        for (int j = 0; j < 9 - 1 - i; j++)
        {
          if (arr[j] > arr[j + 1])
          {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
        }
      }

      for (int i = 0; i < 9; i++)
      {
        cout << arr[i] << endl;
      }
      
      system("pause");

      return 0;
    }
    ```
    ### 5.3 二维数组

    二维数组就是在一维数组上，多加一个维度。

    #### 5.3.1 二维数组定义方式

    二维数组定义的四种方式：

    1. `数据类型  数组名[ 行数 ][ 列数 ];`
    2. `数据类型  数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };`
    3. `数据类型  数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};`
    4. `​ 数据类型  数组名[  ][ 列数 ] = { 数据1，数据2，数据3，数据4};`

    > 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==
    >

    示例：

    ```C++
    int main() {

      //方式1  
      //数组类型 数组名 [行数][列数]
      int arr[2][3];
      arr[0][0] = 1;
      arr[0][1] = 2;
      arr[0][2] = 3;
      arr[1][0] = 4;
      arr[1][1] = 5;
      arr[1][2] = 6;

      for (int i = 0; i < 2; i++)
      {
        for (int j = 0; j < 3; j++)
        {
          cout << arr[i][j] << " ";
        }
        cout << endl;
      }

      //方式2 
      //数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } };
      int arr2[2][3] =
      {
        {1,2,3},
        {4,5,6}
      };

      //方式3
      //数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4  };
      int arr3[2][3] = { 1,2,3,4,5,6 }; 

      //方式4 
      //数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4  };
      int arr4[][3] = { 1,2,3,4,5,6 };

      system("pause");

      return 0;
    }
    ```
    > 总结：在定义二维数组时，如果初始化了数据，可以省略行数
    >

    #### 5.3.2 二维数组数组名

    * 查看二维数组所占内存空间
    * 获取二维数组首地址

    **示例：**

    ```C++
    int main() {

      //二维数组数组名
      int arr[2][3] =
      {
        {1,2,3},
        {4,5,6}
      };

      cout << "二维数组大小： " << sizeof(arr) << endl;
      cout << "二维数组一行大小： " << sizeof(arr[0]) << endl;
      cout << "二维数组元素大小： " << sizeof(arr[0][0]) << endl;

      cout << "二维数组行数： " << sizeof(arr) / sizeof(arr[0]) << endl;
      cout << "二维数组列数： " << sizeof(arr[0]) / sizeof(arr[0][0]) << endl;

      //地址
      cout << "二维数组首地址：" << arr << endl;
      cout << "二维数组第一行地址：" << arr[0] << endl;
      cout << "二维数组第二行地址：" << arr[1] << endl;

      cout << "二维数组第一个元素地址：" << &arr[0][0] << endl;
      cout << "二维数组第二个元素地址：" << &arr[0][1] << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结1：二维数组名就是这个数组的首地址
    >

    > 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小
    >

    #### **5.3.3 二维数组应用案例**

    **考试成绩统计：**

    案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，**请分别输出三名同学的总成绩**

    ||语文|数学|英语|
    | ------| ------| ------| ------|
    |张三|100|100|100|
    |李四|90|50|100|
    |王五|60|70|80|

    **参考答案：**

    ```C++
    int main() {

      int scores[3][3] =
      {
        {100,100,100},
        {90,50,100},
        {60,70,80},
      };

      string names[3] = { "张三","李四","王五" };

      for (int i = 0; i < 3; i++)
      {
        int sum = 0;
        for (int j = 0; j < 3; j++)
        {
          sum += scores[i][j];
        }
        cout << names[i] << "同学总成绩为： " << sum << endl;
      }

      system("pause");

      return 0;
    }
    ```
    # **memset**

    memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。

    函数介绍

    ```C++
    #include<cstring>
    void *memset(void *s, int ch, size_t n);
    ```
    memset解释：将s中当前位置后面的n个字节用ch替换并返回s。

    memset:作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 。

    memset()函数原型是extern void *memset(void *buffer, int c, int count) buffer:为指针或是数组,c:是赋给buffer的值,count:是buffer的长度。

    函数作用  
    1，memset() 函数常用于内存空间初始化。

    2，memset()的深刻内涵:用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化

    例如:memset(a,’\0’,sizeof(a));

    3，memset可以方便的清空一个结构类型的变量或数组。

    如:

    ```C++
    struct sample_struct
    {
        char csName[16];
        int iSeq;
        int iType;
    };
    ```
    对于变量

    `struct sample_strcut stTest;`

    一般情况下，清空stTest的方法:

    `stTest.csName[0]={'\0'}; stTest.iSeq=0; stTest.iType=0;`

    用memset就非常方便:

    `memset(&stTest,0,sizeof(sample_struct));`

    如果是数组:

    `struct sample_struct TEST[10];`

    则

    `memset(TEST,0,sizeof(struct sample_struct)*10);`

    此外:如果结构体中有数组的话还是需要对数组单独进行初始化处理的。

    ```C++
    memset(a,0,4*(n+1));
    ```

[^2]: # 06字符串

    07函数[^3]

    ### 6.1定义字符串

    字符串是指一串文本  
    C语言没有字符串的定义  
    将字符串转换成一个字符数组进行存储

    char a[100];

    string a;

    #### 6.1.1基本定义方式

    ```C++
    #include <iostream>
    using namespace std;
    int main()
    {                //用字符常量逐个初始化 ，加上‘\0’ 结束标志，一维数组=字符串
      char s1[10] = {‘C’,‘h’,‘i’,‘n’,‘a’, ‘\0’};  
                    //用字符串常量整体进行赋值 ，利用双引号定义字符串
      char s2[10] = {“China”}; 
      char s3[] = “China" ;    //省略数组元素个数 ,按照初次创建的长度创建
      
      cout << s1 <<" " << sizeof(s1) << endl;  
      cout << s2 <<" " << sizeof(s2) << endl;
      cout << s3 <<" " << sizeof(s3) <<  endl;
          return 0;
    }

    ```
    #### 错误示例

    ```C++
    char mark[10];
            mark = "C  Program";
            //数组名为地址常量不能被赋初值
         （X） 
      
    char  str1[10] = "computer", str2[10]; （X） 
             str2 = str1;   /*赋值不合法*/
             char s3[] ;    //省略数组元素个数 ,按照初次创建的长度创建，所以不可以为空 

    ```
    #### 6.1.2 使用

    字符串是存放在字符数组中的。引用一个字符串，可以用以下两种方法。

    **用字符数组存放一个字符串，也可以通过数组名和下标引用字符串中一个字符。**  
    char mark[ ] = “PROGRAM”; //mark是数组名，首元素的地址，常量

    **用字符指针变量指向一个字符串常量，通过字符指针变量引用字符串常量。**  
    char *pmark = “PROGRAM”;   //pmark是一个字符指针变量

    指针访问字符串方式

    ```C++
    char *pmark = “PROGRAM”; 
    //*(pmark + i)  相当于 pmark[i]
    ```
    ```C++
    指针申请len空间存放len个字符
    char *p ;
    scanf("%s", p)； （X）
    *
    *int len =7;
    p= (char*)malloc(sizeof(char)*len+1);
    ```
    ```C++
    传递字符数组表示的字符串
    char a[ ] = "hello";
    f1(a);//把数组名传递给指针
    void f1(char p[]){  //p实际上是一个指针变量，字符型指针
       ......
    }
    char c = ‘a’；
    f2(c);
    void f2(char d){}

    ```
    ```C++
    将一个指针传递给字符数组
    Char *p = "12222";
    f(p);//把指针传递给数组
    void f(char[ ] str)  //str实际上是一个指针变量,字符数组形指针
      {
         ………
      }

    ```
    ### 6.2 C++ 中常见的几种输入字符串的方法

    * cin>>

    > 用法：接受一个字符串，遇“空格”、“Tab”、“回车”结束
    >

    ```C++
    char name[20];
        cout << "input name:";
        for(int i = 0 ; i < 20 ; i++)
        {
             cin >> name[i]; //或scanf("%c", &name[i]); 
         } 
    ```
    ```C++
    char a[20];
    cin>>a;//字符数组作为字符串整体输入输出
    /*
    1,输入串长度<数组元素
    2,系统会自动在输入的字符串常量后添加’\0’;
    3,输入多个字符串时，以空格,换行,tab键分隔。
    */
    cout<<a<<endl;
    //输入：abababab
    //输出：abababab
    //输入：abc abc //遇空格结束，所以不能输入多个单词
    //输出：abc
    ```
    字符串中有空格时

    * gets()

    1. 默认是碰到换行符才结束。
    2. gets(a);   //#include <cstdio>
    3. a表示数组名

    ```C++
    char m[20];
    gets(m); //不能写成m=gets();
    cout<<m<<endl;
    //输入：abcabcabc
    //输出：abcabcabc

    //输入：abc abc abc
    //输出：abc abc abc
    ```
    * cin.getline()

    1. 可以用cin的成员函数getline读入，getline函数默认是碰到换行符才结束
    2. cin.getline(a,n); //#include <iostream>
    3. a表示数组名   n表示数组长度

    ```C++
    char m[20];
    cin.getline(m,5); //与上面基本相同。
    cout<<m<<endl;
    //输入：abcdabcd
    //输出：abcd
    //接受5个字符到m中，其中最后一个为'\0'，所以只看到4个字符输出；

    //如果把5改成20：
    //输入：abcabcabc
    //输出：abcabcabc
    //输入：abc abc abc 
    //输出：abc abc abc 
    ```
    > cin.getline(): 接受一个字符串，可以**接收空格并输出**
    >

    **最后一个位置是 '\0'，所以开字符串数组需要开大一个**

    cin.getline()实际上有三个参数，cin.getline(接受字符串到m,接受个数5,结束字符)当第三个参数省略时，系统默认为’\0’ 是‘/n’吧。

    * cin.get()

    > 用法一：cin.get(字符变量名)可以用来接收字符
    >

    ```C++
    char ch;
    ch=cin.get(); //或者cin.get(ch);只能获取一个字符
    cout<<ch<<endl;
    //输入：abab
    //输出：a
    ```
    > 用法二：cin.get(字符数组名，接收字符数)用来接收一行字符串，可以接收空格
    >

    ```C++
    char a[20];
    cin.get(a,20); //有些类似getline。可以输入多个单词，中间空格隔开。
    cout<<a<<endl;
    //输入：abc abc abc
    //输出：abc abc abc
    //输入：abcdeabcdeabcdeabcdeabcde （输入25个字符）
    //输出：abcdeabcdeabcdeabcd （接收19个字符+1个'\0'）
    ```
    > 用法三：cin.get(无参数)没有参数,主要是用于舍弃输入流中的不需要的字符, 或者 **舍弃回车** , 弥补cin.get(字符数组名,接收字符数目)的不足.
    >

    ```C++
    char arr[10];
    cin.get(arr,10);
    cin.get();//用于吃掉回车，相当于getchar();
    cout<<arr<<endl;
    cin.get(arr,5);
    cout<<arr<<endl;
    //输入abcdefghi
    //输出abcdefghi
    //输入abcde
    //输出abcd
    ```
    ```C++
    char arr[10];
    cin.get(arr,10);
    //cin.get();//用于吃掉回车，相当于getchar(); 现在把这行注释掉试试看
    cout<<arr<<endl;
    cin.get(arr,5);
    cout<<arr<<endl;
    //输入abcdefghi
    //输出abcdefghi
    ```
    * getline()

    比较a1,a2;string 可以直接比较

    ```C++
    string a1;
    string a2;
    if(a1==a2)
    cout<<Yes;
    ```
    ```C++
    string str;
    getline(cin,str);
    cout<<str<<endl;
    //输入：abcabcabc  //VC6中有个bug,需要输入两次回车。
    //输出：abcabcabc

    //输入：abc abc abc
    //输出：abc abc abc 
    //和cin.getline()类似，但是cin.getline()属于istream流，
    //而getline()属于string流，是不一样的两个函数
    ```
    如何求string的长度

    ```C++
    #include <iostream>
    using namespace std;
    int main() {
        string s("aaaaaaaab");
        int length1 = s.length();
        int length2 = s.size();
        int length3 = strlen(s.c_str());
        cout<<length1<<' '<<length2<<' '<<length3<<endl;
        return 0;
    }

    ```
    * getchar()

    ```C++
    har ch;
    ch=getchar(); //不能写成getchar(ch);
    cout<<ch<<endl;
    //输入：abcabcabc
    //输出：a
    ```
    getchar()是C语言的函数，C++也可以兼容，但是尽量不用或少用。

    ### 6.2字符串输出

    作为字符数组

    ```C++
     for(i = 0 ; i < 20 ; i++)
       {
            cout << name[i]; //或printf("%c", name[i]); 
        }
       
    ```
    字符数组输出,作为整个字符串输出

    ```C++
        printf(“%s”,数组名);      
        cout << 数组名 
    ```
    输出遇到’\0’结束输出

    输出字符串不包括字符串结束标志符’\0’

    ### 6.3字符处理函数

    ![](https://secure2.wostatic.cn/static/ncp8r17AmxRF8NzvfdaT3Z/image.png)

    需要加#include <cstring>

    ### 6.4字符处理相关应用

    #### 例一、代码填空：反转串

    我们把“cba”称为“abc”的反转串。  
    下面的代码可以把buf中的字符反转。其中n表示buf中待反转的串的长度。请补充缺少的代码。

    ```C++
    void reverse_str(char* buf, int n)
    {
      if(n<2) 
        return;
      char tmp = buf[0];
      buf[0] = buf[n-1];
      buf[n-1] = tmp;
       reverse_str(buf+1, n-2);

    }
    ```
    #### 例二、轮换

    串“abcd”每个字符都向右移位，最右的移动到第一个字符的位置，就变为“dabc”。这称为对串进行位移=1的轮换。同理，“abcd”变为：“cdab”则称为位移=2的轮换。下面的代码实现了对串s进行位移为n的轮换。请补全缺失的代码。

    ```C++
    void shift(char* s, int n)
    {
      char* p;
      char* q;
      int len = strlen(s);
      if(len==0) return;
        if(n<=0 || n>=len) return;
      char* s2 = (char*)malloc((len+1)*sizeof(char));
       p = s;
       q = s2 + n % len;


    ```
    ```C++
    while(*p)
    {
      *q++ = *p++;
      if(q-s2>=len)
      {
         *q = '\0';
          q = s2;
       }
    }
       strcpy(s,s2);
       free(s2);
    }


    ```
    ## 题

    **编程题：密码发生器**  
    在对银行账户等重要权限设置密码的时候，我们常常遇到这样的烦恼：如果为了好记用生日吧，容易被破解，不安全；如果设置不好记的密码，又担心自己也会忘记；如果写在纸上，担心纸张被别人发现或弄丢了。这个程序的任务就是把一串拼音字母转换为6位数字（密码）。我们可以使用任何好记的拼音串(比如名字，王喜明，就写：wangximing)作为输入，程序输出6位数字。  
    变换的过程如下：  
    第一步，把字符串6个一组折叠起来，比如wangximing则变为：  
    wangxi  
    ming  
    第二步，把所有垂直在同一个位置的字符的ascii码值相加，得出6个数字，如上  面的例子，则得出：  
    228 202 220 206 120 105  
    第三步. 再把每个数字“缩位”处理：就是把每个位的数字相加，得出的数字如果不是一位数字，就再缩位，直到变成一位数字为止。例如: 228 => 2+2+8=12 => 1+2=3  
    上面的数字缩位后变为：344836, 这就是程序最终的输出结果！  
    要求程序从标准输入接收数据，在标准输出上输出结果。

    **输入**  
    第一行是一个整数n（<100），表示下边有多少输入行，接下来是n行字符串，就是等待变换的字  
    符串(长度小于100)。  
    **输出**  
    变换后的6位密码  
    **样例输入**  
    5  
    zhangfeng  
    wangximing  
    jiujingfazi  
    woaibeijingtiananmen  
    haohaoxuexi  
    **样例输出**  
    772243  
    344836  
    297332  
    716652  
    875843


[^3]: # 07函数

    08递归（未完成）[^4]

    ## 7 函数

    ### 7.1 概述

     **作用** ：**将一段经常使用的代码封装起来，减少重复代码**

    一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。

    **多态：一个符号,多种含义**

    C++代码在编译的的侯就可以确定 getMax调用的是谁,这个就是编译时多态  
    编译时多态 （函数重载）

    函数重载：函数名字相同,但是形参列表不同，返回类型一致。

    ### 7.2 函数的定义

    函数的定义一般主要有5个步骤：

    1、返回值类型

    2、函数名

    3、参数表列

    4、函数体语句

    5、return 表达式

    **语法：**

    ```C++
    返回值类型 函数名 （参数列表）
    {

           函数体语句

           return表达式

    }
    ```
    * 返回值类型 ：一个函数可以返回一个值。在函数定义中
    * 函数名：给函数起个名称,标注格式：动词+名词
    * 参数列表：使用该函数时，传入的数据
    * 函数体语句：花括号内的代码，函数内需要执行的语句
    * return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据

    **示例：**定义一个加法函数，实现两个数相加

    ```C++
    //函数定义
    int add(int num1, int num2)
    {
      int sum = num1 + num2;
      return sum;
    }
    ```
    ### 7.3 函数的调用

    功能：使用定义好的函数

    **语法：**​`​ 函数名（参数）`

    **示例：**

    ```C++
    //函数定义
    int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参
    {
      int sum = num1 + num2;
      return sum;
    }

    int main() {

      int a = 10;
      int b = 10;
      //调用add函数
      int sum = add(a, b);//调用时的a，b称为实际参数，简称实参
      cout << "sum = " << sum << endl;

      a = 100;
      b = 100;

      sum = add(a, b);
      cout << "sum = " << sum << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参
    >

    ### 7.4 值传递（传值）

    * 所谓值传递，就是函数调用时实参将数值传入给形参
    * 值传递时，==如果形参发生，并不会影响实参==

    **示例：**

    ```C++
    void swap(int num1, int num2)
    {
      cout << "交换前：" << endl;
      cout << "num1 = " << num1 << endl;
      cout << "num2 = " << num2 << endl;

      int temp = num1;
      num1 = num2;
      num2 = temp;

      cout << "交换后：" << endl;
      cout << "num1 = " << num1 << endl;
      cout << "num2 = " << num2 << endl;

      //return ; 当函数声明时候，不需要返回值，可以不写return
    }

    int main() {

      int a = 10;
      int b = 20;

      swap(a, b);

      cout << "mian中的 a = " << a << endl;
      cout << "mian中的 b = " << b << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结： 值传递时，形参是修饰不了实参的
    >

    **函数之间共享数据的三种方式:全局变量,传指针,传引用**

    #### 7.4.1传引用&地址传递

    加一个&，使实参和形参同步变化。

    **数组的时候不用加引用符号**

    #### 7.4.2全局变量，不推荐使用

    ### 7**.5 函数的常见样式**

    常见的函数样式有4种

    1. 无参无返
    2. 有参无返
    3. 无参有返
    4. 有参有返

    **示例：**

    ```C++
    //函数常见样式
    //1、 无参无返
    void test01()
    {
      //void a = 10; //无类型不可以创建变量,原因无法分配内存
      cout << "this is test01" << endl;
      //test01(); 函数调用
    }

    //2、 有参无返
    void test02(int a)
    {
      cout << "this is test02" << endl;
      cout << "a = " << a << endl;
    }

    //3、无参有返
    int test03()
    {
      cout << "this is test03 " << endl;
      return 10;
    }

    //4、有参有返
    int test04(int a, int b)
    {
      cout << "this is test04 " << endl;
      int sum = a + b;
      return sum;
    }
    ```
    ### 7.6 函数的声明

    **作用：** 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

    * 函数的 **声明可以多次** ，但是函数的**定义只能有一次**

    **示例：**

    ```C++
    //声明可以多次，定义只能一次
    //声明
    int max(int a, int b);
    int max(int a, int b);
    //定义
    int max(int a, int b)
    {
      return a > b ? a : b;
    }

    int main() {

      int a = 100;
      int b = 200;

      cout << max(a, b) << endl;

      system("pause");

      return 0;
    }
    ```
    ### 7.7 函数的分文件编写

    **作用：**让代码结构更加清晰

    函数分文件编写一般有4个步骤

    1. 创建后缀名为.h的头文件
    2. 创建后缀名为.cpp的源文件
    3. 在头文件中写函数的声明
    4. 在源文件中写函数的定义

    **示例：**

    ```C++
    //swap.h文件
    #include<iostream>
    using namespace std;

    //实现两个数字交换的函数声明
    void swap(int a, int b);

    ```
    ```C++
    //swap.cpp文件
    #include "swap.h"

    void swap(int a, int b)
    {
      int temp = a;
      a = b;
      b = temp;

      cout << "a = " << a << endl;
      cout << "b = " << b << endl;
    }
    ```
    ```C++
    //main函数文件
    #include "swap.h"
    int main() {

      int a = 100;
      int b = 200;
      swap(a, b);

      system("pause");

      return 0;
    }

    ```

[^4]: # 08递归（未完成）

    09指针（C++部分重点使用）[^5]


[^5]: # 09指针（C++部分重点使用）

    10结构体[^6]

    ## 9指针

    ### 9.1 指针的基本概念

    **指针的作用：** 可以通过指针间接访问内存

    * 内存编号是从0开始记录的，一般用十六进制数字表示
    * 可以利用指针变量保存地址

    ### 9.2 指针变量的定义和使用

    指针变量定义语法： `数据类型 * 变量名；`

    **示例：**

    ```C++
    int main() {

      //1、指针的定义
      int a = 10; //定义整型变量a

      //指针定义语法： 数据类型 * 变量名 ;
      int * p;

      //指针变量赋值
      p = &a; //指针指向变量a的地址
      cout << &a << endl; //打印数据a的地址
      cout << p << endl;  //打印指针变量p

      //2、指针的使用
      //可以通过 解引用 的方式找到指针指向的内存
        //指针前加 * 代表引用，找到指针
      //通过*操作指针变量指向的内存中的数据
      cout << "*p = " << *p << endl;

      system("pause");

      return 0;
    }
    ```
    指针变量和普通变量的区别

    * 普通变量存放的是数据,指针变量存放的是地址
    * 指针变量可以通过" * "操作符，操作指针变量指向的内存空间，这个过程称为解引用

    > 总结1： 我们可以通过 & 符号 获取变量的地址
    >

    > 总结2：利用指针可以记录地址
    >

    > 总结3：对指针变量解引用，可以操作指针指向的内存
    >

    ### 9.3 指针所占内存空间

    提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？

    **示例：**

    ```C++
    int main() {

      int a = 10;

      int * p;
      p = &a; //指针指向数据a的地址

      cout << *p << endl; //* 解引用
      cout << sizeof(p) << endl;
      cout << sizeof(char *) << endl;
      cout << sizeof(float *) << endl;
      cout << sizeof(double *) << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结：所有指针类型在32位操作系统(x86)下是4个字节，64位系统(x64) 占据8个
    >

    ### 9.4 空指针和野指针

     **空指针** ：指针变量指向内存中编号为0的空间

    用途：初始化指针变量

    注意：空指针指向的内存是不可以访问的

    **示例1：空指针**

    ```C++
    int main()
    {

      //指针变量p指向内存地址编号为0的空间
      int * p = NULL;

      //访问空指针报错 
      //内存编号0 ~255为系统占用内存，不允许用户访问
      cout << *p << endl;

      system("pause");

      return 0;
    }
    ```
     **野指针** ：指针变量指向非法的内存空间

    **示例2：野指针**

    ```C++
    int main() {

      //指针变量p指向内存地址编号为0x1100的空间
      int * p = (int *)0x1100;//(int *)是强转
        //这种情况语法合理，但是读取访问权限不合理。因为没申请这个空间。

      //访问野指针报错 
      cout << *p << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结：空指针和野指针都不是我们申请的空间，因此不要访问。
    >

    ### 9.5 const修饰指针

    const修饰指针有三种情况

    1. const修饰指针   --- 常量指针
    2. const修饰常量   --- 指针常量
    3. const即修饰指针，又修饰常量

    **示例：**

    ```c++
    int main() {

      int a = 10;
      int b = 10;

      //const修饰的是指针，指针指向可以改，指针指向的值不可以更改
      const int * p1 = &a; 
      p1 = &b; //正确
      //*p1 = 100;  报错

      //const修饰的是常量，指针指向不可以改，指针指向的值可以更改
      int * const p2 = &a;
      //p2 = &b; //错误
      *p2 = 100; //正确

        //const既修饰指针又修饰常量
      const int * const p3 = &a;
      //p3 = &b; //错误
      //*p3 = 100; //错误

      system("pause");

      return 0;
    }
    ```
    > 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量
    >

    * *const int * p叫常量指针，*p的操作不可** （p- >也不可）

    **int * const p叫指针常量，p的操作不可**

    ### 9.6 指针和数组

    作用：利用指针访问数组中元素

    **示例：**

    ```C++
    int main() {

      int arr[] = { 1,2,3,4,5,6,7,8,9,10 };

      int * p = arr;  //指向数组的指针

      cout << "第一个元素： " << arr[0] << endl;
      cout << "指针访问第一个元素： " << *p << endl;

      for (int i = 0; i < 10; i++)
      {
        //利用指针遍历数组
        cout << *p << endl;
        p++;
      }

      system("pause");

      return 0;
    }
    ```
    ### 9.7 指针和函数

    作用：利用指针作函数参数，可以修改实参的值

    **示例：**

    ```C++
    //值传递
    void swap1(int a ,int b)
    {
      int temp = a;
      a = b; 
      b = temp;
    }
    //地址传递
    void swap2(int * p1, int *p2)
    {
      int temp = *p1;
      *p1 = *p2;
      *p2 = temp;
    }

    int main() {

      int a = 10;
      int b = 20;
      swap1(a, b); // 值传递不会改变实参

      swap2(&a, &b); //地址传递会改变实参

      cout << "a = " << a << endl;

      cout << "b = " << b << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递
    >

    ### 9.8 指针、数组、函数

    案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序

    例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };

    **示例：**

    int * a

    ```c++
    //冒泡排序函数
    void bubbleSort(int * arr, int len)  //int * arr 也可以写为int arr[]
    {
      for (int i = 0; i < len - 1; i++)
      {
        for (int j = 0; j < len - 1 - i; j++)
        {
          if (arr[j] > arr[j + 1])
          {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
        }
      }
    }

    //打印数组函数
    void printArray(int arr[], int len)
    {
      for (int i = 0; i < len; i++)
      {
        cout << arr[i] << endl;
      }
    }

    int main() {

      int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
      int len = sizeof(arr) / sizeof(int);

      bubbleSort(arr, len);

      printArray(arr, len);

      system("pause");

      return 0;
    }
    ```
    > 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针
    >

    ### 9.9指针和字符串


[^6]: # 10结构体

    11面向对象[^7]

    ## 10结构体

    ### 10.1 结构体基本概念

    结构体属于用户 **自定义的数据类型  ​**，允许用户存储不同的数据类型

    ### 10.2 结构体定义和使用

     **语法：** `struct 结构体名 { 结构体成员列表 }；`

    通过结构体创建变量的方式有三种：

    * struct 结构体名 变量名
    * struct 结构体名 变量名 = { 成员1值 ， 成员2值...}
    * 定义结构体时顺便创建变量

    **示例：**

    ```C++
    //结构体定义
    struct student
    {
      //成员列表
      string name;  //姓名
      int age;      //年龄
      int score;    //分数
    }stu3; //结构体变量创建方式3 

    int main() {

      //结构体变量创建方式1
      struct student stu1; //struct 关键字可以省略

      stu1.name = "张三";
      stu1.age = 18;
      stu1.score = 100;

      cout << "姓名：" << stu1.name << " 年龄：" << stu1.age  << " 分数：" << stu1.score << endl;

      //结构体变量创建方式2
      struct student stu2 = { "李四",19,60 };

      cout << "姓名：" << stu2.name << " 年龄：" << stu2.age  << " 分数：" << stu2.score << endl;

      stu3.name = "王五";
      stu3.age = 18;
      stu3.score = 80;

      cout << "姓名：" << stu3.name << " 年龄：" << stu3.age  << " 分数：" << stu3.score << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结1：定义结构体时的关键字是struct，不可省略
    >

    > 总结2：创建结构体变量时，关键字struct可以省略
    >

    > 总结3：结构体变量利用操作符 ''.''  访问成员
    >

    **例题：**制表格式

    ### 10.3 结构体数组

    **作用：**将自定义的结构体放入到数组中方便维护

    **语法：**​`​ struct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }`

    **示例：**

    ```C++
    //结构体定义
    struct student
    {
      //成员列表
      string name;  //姓名
      int age;      //年龄
      int score;    //分数
    }

    int main() {

      //结构体数组
      struct student arr[3]=
      {
        {"张三",18,80 },
        {"李四",19,60 },
        {"王五",20,70 }
      };

      for (int i = 0; i < 3; i++)
      {
        cout << "姓名：" << arr[i].name << " 年龄：" << arr[i].age << " 分数：" << arr[i].score << endl;
      }

      system("pause");

      return 0;
    }
    ```
    ### 10.4 结构体指针

    作用：通过指针访问结构体中的成员

    * 利用操作符 `-> ​`可以通过结构体指针访问结构体属性

    **示例：**

    ```C++
    //结构体定义
    struct student
    {
      //成员列表
      string name;  //姓名
      int age;      //年龄
      int score;    //分数
    };

    int main() {

      struct student stu = { "张三",18,100, };

      struct student * p = &stu;

      p->score = 80; //指针通过 -> 操作符可以访问成员

      cout << "姓名：" << p->name << " 年龄：" << p->age << " 分数：" << p->score << endl;

      system("pause");

      return 0;
    }
    ```
    > 操作符 来访问结构体中的成员
    >

    ### 10.5 结构体嵌套结构体

    **作用：** 结构体中的成员可以是另一个结构体

    例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体

    **示例：**

    ```C++
    //学生结构体定义
    struct student
    {
      //成员列表
      string name;  //姓名
      int age;      //年龄
      int score;    //分数
    };

    //教师结构体定义
    struct teacher
    {
        //成员列表
      int id; //职工编号
      string name;  //教师姓名
      int age;   //教师年龄
      struct student stu; //子结构体 学生
    };

    int main() {

      struct teacher t1;
      t1.id = 10000;
      t1.name = "老王";
      t1.age = 40;

      t1.stu.name = "张三";
      t1.stu.age = 18;
      t1.stu.score = 100;

      cout << "教师 职工编号： " << t1.id << " 姓名： " << t1.name << " 年龄： " << t1.age << endl;

      cout << "辅导学员 姓名： " << t1.stu.name << " 年龄：" << t1.stu.age << " 考试分数： " << t1.stu.score << endl;

      system("pause");

      return 0;
    }
    ```
    总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题

    ### 10.6 结构体做函数参数

    作用：将结构体作为参数向函数中传递

    传递方式有两种：

    * 值传递
    * 地址传递

    **示例：**

    ```C++
    //学生结构体定义
    struct student
    {
      //成员列表
      string name;  //姓名
      int age;      //年龄
      int score;    //分数
    };

    //值传递
    void printStudent(student stu )
    {
      stu.age = 28;
      cout << "子函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;
    }

    //地址传递
    void printStudent2(student *stu)
    {
      stu->age = 28;
      cout << "子函数中 姓名：" << stu->name << " 年龄： " << stu->age  << " 分数：" << stu->score << endl;
    }

    int main() {

      student stu = { "张三",18,100};
      //值传递
      printStudent(stu);
      cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age << " 分数：" << stu.score << endl;

      cout << endl;

      //地址传递
      printStudent2(&stu);
      cout << "主函数中 姓名：" << stu.name << " 年龄： " << stu.age  << " 分数：" << stu.score << endl;

      system("pause");

      return 0;
    }
    ```
    > 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递
    >

    ### 10.7 结构体中 const使用场景

    作用：用const来防止误操作

    ```C++
    //值传递：优点，不会改变原数据；缺点，需要复制浪费资源
    void printStudent(student s);
    //传指针：优点，不需要复制，缺点，会改变原数据
    void printStudent(student *s);
    //const传指针：***优点不需要复制，不会改变原数据***
    void printStudent(const student *s);
    ```
    **示例：**

    ```C++
    //学生结构体定义
    struct student
    {
      //成员列表
      string name;  //姓名
      int age;      //年龄
      int score;    //分数
    };

    //const使用场景
    void printStudent(const student *stu) //加const防止函数体中的误操作
    {
      //stu->age = 100; //操作失败，因为加了const修饰
      cout << "姓名：" << stu->name << " 年龄：" << stu->age << " 分数：" << stu->score << endl;

    }

    int main() {

      student stu = { "张三",18,100 };

      printStudent(&stu);

      system("pause");

      return 0;
    }
    ```
    ### 10.8 结构体案例

    #### 10.8.1 案例1

    **案例描述：**

    学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下

    设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员

    学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值

    最终打印出老师数据以及老师所带的学生数据。

    **示例：**

    ```C++
    struct Student
    {
      string name;
      int score;
    };
    struct Teacher
    {
      string name;
      Student sArray[5];
    };

    void allocateSpace(Teacher tArray[] , int len)
    {
      string tName = "教师";
      string sName = "学生";
      string nameSeed = "ABCDE";
      for (int i = 0; i < len; i++)
      {
        tArray[i].name = tName + nameSeed[i];
      
        for (int j = 0; j < 5; j++)
        {
          tArray[i].sArray[j].name = sName + nameSeed[j];
          tArray[i].sArray[j].score = rand() % 61 + 40;
        }
      }
    }

    void printTeachers(Teacher tArray[], int len)
    {
      for (int i = 0; i < len; i++)
      {
        cout << tArray[i].name << endl;
        for (int j = 0; j < 5; j++)
        {
          cout << "\t姓名：" << tArray[i].sArray[j].name << " 分数：" << tArray[i].sArray[j].score << endl;
        }
      }
    }

    int main() {

      srand((unsigned int)time(NULL)); //随机数种子 头文件 #include <ctime>

      Teacher tArray[3]; //老师数组

      int len = sizeof(tArray) / sizeof(Teacher);

      allocateSpace(tArray, len); //创建数据

      printTeachers(tArray, len); //打印数据

      system("pause");

      return 0;
    }
    ```
    #### 10.8.2 案例2

    **案例描述：**

    设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。

    通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。

    五名英雄信息如下：

    ```C++
    {"刘备",23,"男"},
    {"关羽",22,"男"},
    {"张飞",20,"男"},
    {"赵云",21,"男"},
    {"貂蝉",19,"女"},
    ```
    **示例：**

    ```C++
    //英雄结构体
    struct hero
    {
      string name;
      int age;
      string sex;
    };
    //冒泡排序
    void bubbleSort(hero arr[] , int len)
    {
      for (int i = 0; i < len - 1; i++)
      {
        for (int j = 0; j < len - 1 - i; j++)
        {
          if (arr[j].age > arr[j + 1].age)
          {
            hero temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
        }
      }
    }
    //打印数组
    void printHeros(hero arr[], int len)
    {
      for (int i = 0; i < len; i++)
      {
        cout << "姓名： " << arr[i].name << " 性别： " << arr[i].sex << " 年龄： " << arr[i].age << endl;
      }
    }

    int main() {

      struct hero arr[5] =
      {
        {"刘备",23,"男"},
        {"关羽",22,"男"},
        {"张飞",20,"男"},
        {"赵云",21,"男"},
        {"貂蝉",19,"女"},
      };

      int len = sizeof(arr) / sizeof(hero); //获取数组元素个数

      bubbleSort(arr, len); //排序

      printHeros(arr, len); //打印

      system("pause");

      return 0;
    }
    ```
    7-6 简单通讯录

    程序输入整数N，再输入N个学生的姓名和电话号码。最后以表格形式输出。

    ### 输入格式:

    第一行，整数N(N<100),接下来N行，是N个学生的姓名(无空格不超过20个字符)和电话(无空格不超过20个字符)。

    ### 输出格式:

    见样例，严格按样例格式输出。

    ### 输入样例:

    ```
    in
    3

    AAAAABBBBBCCCCCDDDDD       13000001234

    Yulong                     13666667777

    Gaoyuhang                  18601105886

    结尾无空行
    ```
    ### 输出样例:

    ```
    out
    +---------------------------------------------+

    | name                 | phone                |

    +----------------------+----------------------+

    | AAAAABBBBBCCCCCDDDDD | 13000001234          |

    +----------------------+----------------------+

    | Yulong               | 13666667777          |

    +----------------------+----------------------+

    | Gaoyuhang            | 18601105886          |

    +---------------------------------------------+

    结尾无空行
    ```
    ```
    #include <iostream>

    #include <cstdio>

    #include <string>

    #include <cmath>

    using namespace std;

    int main()

    {

      struct student

      {

        char name [40];

        char num [40];

      };

      int n;

      scanf("%d", &n);

      student stu[n];

        //存入信息

      for (int i = 0; i < n; i++)

      {

        scanf("%s%s", stu[i].name, stu[i].num);

      }

      cout << "+---------------------------------------------+" << endl;

      cout << "| name                 | phone                |" << endl;

      for (int i = 0; i < n; i++)

      {

        cout << "+----------------------+----------------------+" << endl;

        printf("| %-21s| %-21s|\n", stu[i].name, stu[i].num);//%-21s 左对齐，共占21个字符宽度

      }

        cout << "+---------------------------------------------+";

      return 0;

    }
    ```

[^7]: # 11面向对象

    12相关知识[^8]

    **面向过程的结构化程序设计方法**

    自顶向下、逐步求精。采用模块分解与功能抽象，自顶向下、分而治之。  
    程序的模块是由函数构成的。  
    程序=数据结构+算法  
    可重用性差

    **面向对象的方法**

    将数据及对数据的操作方法封装在一起，作为一个相互依存、不可分离的整体——对象。对同类型对象抽象出其共性，形成类。对象与对象之间通过消息进行通讯。  
    程序的模块是由类构成的。  
    程序＝对象＋消息  
    对象＝算法＋数据结构  
    特点：封装性、继承性、多态性

    # 1**本章主要内容**

    # 1、OOP的基本特点

    ## 1 **抽象**

    抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。

    1. 先注意问题的本质及描述，其次是实现过程或细节。
    2. 数据抽象：描述某类对象的属性或状态（此类对象区别于彼类对象的特征）。
    3. 行为抽象：描述某类对象的共有的行为特征或具有的功能。
    4. ==抽象的实现：通过类的声明。==

    ### 1.1 **钟表**

    * 数据抽象：  
      int Hour,int Minute,int Second
    * 行为抽象：  
      SetTime(),ShowTime()

    #### **1.1.1 封装实例——钟表类**

    ```C++
    class  Clock
    {
            public: void SetTime(int NewH,int NewM,int NewS);
                    void ShowTime();
            private: int Hour,Minute,Second;
    };
    ```
    ### 1.2**抽象实例——人**

    * 数据抽象：  
      char *name, char *gender, int age, int id
    * 行为抽象：  
      生物属性角度：GetCloth(),  Eat(),  Walk(),…  
      社会属性角度：Work(), Study() ,…

    ### 1.3**抽象实例--案例中的类**

    ## 2 封装

    封装就是将抽象得到的数据和行为相结合，形成一个有机的整体，也就是将数据与操作数据的函数代码进行有机地结合，形成“类”。其中的数据和函数都是类的成员。

    目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。

    实现封装：类声明中的{ }限定了类的边界

    ### 2.1 封装实例——钟表类

    ```C++
    class  Clock
    {
            public: void SetTime(int NewH,int NewM,                                         int NewS);                 void ShowTime();
            private: int Hour,Minute,Second;
    };
    ```
    ## 3 继承与派生

    继承与派生是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体、更详细的说明。

    实现：声明派生类

    ### 3.1 案例中的继承

    ## 4 多态性

    多态：同一名称，不同的功能实现方式。

    目的：达到行为标识统一，减少程序中标识符的个数。

    实现：重载函数和虚函数——第八章

    # 2、类和对象

    ## 2.1 类

    ### 2.1.1 c++中的类

    类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。

    利用**类**可以实现 **数据的封装、隐藏、继承与派生** 。

    利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。

    ### 2.1.2 类的定义

    类是一种用户自定义类型，定义形式：

    ```C++
    class 类名称
    {
           public:
                     公有成员（外部接口）
           private:
                     私有成员
           protected:
                     保护型成员
    };  //最后的分号不可少，这是一条说明语句
    ```
    ### 2.1.3 类的成员

    ```C++
    class  Clock
    {
      public:    void SetTime(int NewH, int NewM, int NewS);   void ShowTime();
      private: 
          int Hour, Minute, Second; //与一般的变量声明相同
    };
    ```
    #### 2.1.3.1 类成员的访问控制

    * 类的访问控制机制  
      在C++中，类的成员是“有所见有所不见”的，这种可见性是由访问控制符决定的。
    * C++中，有三种访问控制符：  
      private—仅本类能访问  
      protected—家族访问（后）

      ```
      public—谁都能访问
      ```

    #### 2.1.3.2 使用说明

    1. 类的三个访问控制符可以任意顺序出现任意次，一般相同的在一起，公有类型放在最前面。
    2. 不能在类声明中给数据成员赋初值。
    3. 数据成员不能用auto、register、extern修饰。

    #### 2.1.3.3 类中缺省的访问属性是私有（private）

    ```C++
    class complex{
        double real;
        double imag;
      public:
        void init(double r,double i)
        { real=r; imag=i; }
        double realcomplex()
        { return real;}
      }；
    ```
    ### 2.1.4 成员函数定义

    成员函数定义有两种方式：

    类中声明原型，类外定义；

    1. 类外定义的具体形式如下：  
        返回值类型  类名::函数成员名(参数表)  
        {  
        函数体  
        }

    ```C++
    void Clock :: SetTime(int NewH=0, int NewM=0, int NewS=0)
    {
            Hour=NewH;
            Minute=NewM;
            Second=NewS;
    }
    void Clock :: ShowTime()
    {
            cout<<Hour<<":"<<Minute<<":"<<Second;
    }
    //允许声明重载函数和带默认形参值的函数
    ```
    1. 类内直接定义；

    ```C++
    class  Clock
    {
            public: 
                 void SetTime(int NewH,  int NewM, int NewS);          void ShowTime()
            {cout<<Hour<<“:”<<Minute<<“:”<<Second<<endl;}
            private: 
                  int Hour,Minute,Second;
    };

    ```
    > 这样定义的成员函数是一种内联函数（在编译的时候插入到每一个调用它的地方），亦可在类外定义内联函数，不过要在函数前加上inline。
    >

    ### 2.1.5 内联成员函数

    * 为了提高运行时的效率，对于较简单的函数可以声明为内联形式。
    * 内联成员函数体中不要有复杂结构（如循环语句和switch语句）。
    * 在类中声明内联成员函数的方式：  
      将函数体放在类的声明中。  
      在类外定义内联函数，不过要在函数前加上inline。

    ## 2.2 对象

    ### 2.2.1 对象的定义

    对象：对象是类的变量，是现实世界的实体；人们认识世界的基本单位。

    对象与类之间的关系：  
    [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uvOL8xw7-1638521462514)(assets/image-20211127220345-ojfh0tj.png)]

    对象的定义：和C中的结构类型定义一样，即用类型声明变量。

    ### 2.2.2 类与对象的关系

    [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VB8gfiHZ-1638521462514)(assets/image-20211127220650-9429i2k.png)]

    ### 2.2.3 类中成员的访问方式

    [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-St5qoSmr-1638521462515)(assets/image-20211127220752-e0c2j6q.png)]

    # 3、构造函数

    ## 3.1 定义

    * 构造函数的作用是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。
    * 在对象创建时由系统自动调用。
    * 如果程序中未声明，则系统自动产生出一个默认形式的构造函数。
    * 允许为内联函数、重载函数、带默认形参值的函数。

    ## 3.2 构造函数举例

    ```C++
    class Clock
    {
    public:
      Clock (int NewH, int NewM, int NewS);//构造函数
      void SetTime(int NewH, int NewM, int NewS);
      void ShowTime();
    private:
      int Hour,Minute,Second;
    };
    ```
    [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jGhyxOhL-1638521462516)(assets/image-20211127221034-3uc1t76.png)]

    ## 3.3 构造函数的实现

    ```C++
    Clock::Clock(int NewH, int NewM, int NewS)
    {
      Hour= NewH;
      Minute= NewM;
      Second= NewS;
    }
    //建立对象时构造函数的作用：
    int main()
    {
        Clock  c (0,0,0); //隐含调用构造函数，将初始值作为实参。
        c.ShowTime();
    }
    ```
    ## 3.4 拷贝构造函数

    拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用。

    ```C++
    class 类名
    {  public :
           类名（形参）；//构造函数
           类名（类名 &对象名）；//拷贝构造函数
               ...
    }；
    类名:: 类名（类名 &对象名）//拷贝构造函数的实现
    {    函数体    }
    ```
    [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8HPCHFTy-1638521462516)(assets/image-20211127221331-xg9twi0.png)]

    如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个默认的拷贝构造函数。  
    这个默认的构造函数执行的功能是：把初始值对象的每个数据成员的值，都复制到将要建立的对象的对应数据成员。

    ## 3.5 引用拷贝构造函数的三种情况

    1、当用类的一个对象去初始化该类的另一个对象时系统自动调用拷贝构造函数实现拷贝赋值。

    ```C++
    void main(void)
    {  Point A(1,2);
       Point B(A); //拷贝构造函数被调用
       cout<<B.GetX()<<endl;
    }
    ```
    2、若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。例如：

    ```C++
    void fun1(Point p)
    {   cout<<p.GetX()<<endl;
    } 
    void main()
    {   Point A(1,2);
        fun1(A); //调用拷贝构造函数
    }   
    ```
    3、当函数的返回值是类对象时，系统自动调用拷贝构造函数。例如：

    ```C++
    Point fun2()
    {    Point A(1,2);
         return A; //调用拷贝构造函数将A的值烤到临时对象
    }
    void main()
    {
         Point B;
         B=fun2(); 
    }
    ```
    ### 3.5.1 拷贝构造函数举例

    ```C++
    #include <iostream>
    using namespace std;
    class Point
    {
       public:
           Point(int xx=0,int yy=0){X=xx; Y=yy;}
           Point(Point&  p);
           int GetX() {return X;}
           int GetY() {return Y;}
       private:
           int  X,Y;
    };
    ```
    ```C++
    Point::Point (Point&  p)
    {
          X=p.X;
          Y=p.Y;
          cout<<"拷贝构造函数被调用"<<endl;
    }
    ```
    ```C++
    //形参为Point类的函数
    void fun1(Point p)
    {    cout<<p.GetX()<<endl;
    }
    //返回值为Point类对象的函数
    Point fun2()
    {
             Point A(1,2);
             return A;
    }
    ```
    ```C++
    //主程序
    int main()
    {
             Point A(4,5);//第一个对象Ａ
             Point B(A);//Ａ初始化Ｂ第一次调用拷贝函数
             cout<<B.GetX()<<endl;
             fun1(B);//对象Ｂ为fun1实参，第二次调用
            B=fun2();//函数返回值是类对象，第三次调用
            cout<<B.GetX()<<endl;
    }
    ```
    # 4、析构函数

    * 完成对象被删除前的一些清理工作。
    * 在对象的生存期即将结束的时刻系统自动调用它，然后再释放此对象所属的空间。
    * 如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数。

    ## 4.1 构造函数和析构函数

    ```C++
    #include<iostream>
    using namespace std;
    class Point
    {   
      public:
        Point(int xx,int yy);
        ~Point();
        //...其它函数原形
      private:
        int X,int Y;
    };
    ```
    ```C++
    Point::Point(int xx,int yy)
    {     X=xx;   
          Y=yy;
    }
    Point::~Point()
    {
    }

    ```
    ```C++
    #include <iostream>
    #include <cmath>
    using namespace std;
    class Point
    {
    public:
      Point(int xx=0, int yy=0) 
      {
        X=xx; Y=yy; //countP++; 
      } 
        Point(Point &p)   //拷贝构造函数
        {
          X = p.X;
          Y = p.Y;
      }
      int GetX() {
        return X;
      }
      int GetY() {
        return Y;
      }
      static void GetC() { //非静态方法引用了静态成员变量，需要在类的外部初始化静态成员 
        //cout << x << endl; //错误 
        cout<<" Object id=" << countP << endl;
      }
      static void GetC(Point &p) { //非静态方法引用了静态成员变量，需要在类的外部初始化静态成员 
        cout << p.X << endl; //错误 
        cout<<" Object id=" << countP << endl;
      }
      friend double computeDistance(Point &a, Point &b); //友元函数,可以访问Point私有成员 
      friend class Line; //友元类，可以访问Point私有成员 
    private:
      int X, Y;
      static int countP;
    };
    class Line{
      double computeDistance()
      {
        return sqrt((a.X - b.X) * (a.X- b.X) + (a.Y - b.Y) * (a.Y - b.Y)); //因为Line是Point的友元类，所以可以直接访问Point里的私有属性 
      }
      private:
        Point a, b;
    };

    int Point::countP = 0;
    double computeDistance(Point &a, Point &b)
    {
      //cout << a.GetX() ;//访问对象里共有的方法，没有问题
      return sqrt((a.X - b.X) * (a.X- b.X) + (a.Y - b.Y) * (a.Y - b.Y)); //因为computeDistance是Point的友元函数，所以可以直接访问Point里的私有属性 
    }

    int main()
    {
        Point::GetC(); //没有任何对象的时候就可以调用静态方法和静态属性

      Point A(4,5);
      cout<<"Point A,"<<A.GetX()<<","<<A.GetY();
      A.GetC();
      Point B(A);
      cout<<"Point B,"<<B.GetX()<<","<<B.GetY();
      B.GetC();
      return 0;
    }

    ```

[^8]: # 12相关知识

    02面向对象部分[^9]

    ## 函数重载是静态多态，实践作业中要求必须含有一个多态

    **函数重载是一种静态多态：**

    **（1）多态：用同一个东西表示不同的形态；**

    **（2）多态分为：  静态多态（编译时的多态）；**

     **动态多态（运行时的多态）；**

    **（3）函数重载是一种静态多态；**

    ‍

    ## virtual

    virtual在英文中表示“虚”、“虚拟”的含义。c++中的关键字“virtual”主要用在两个方面：虚函数与虚基类。下面将分别从这两个方面对virtual进行介绍。

    ### 1.虚函数

    虚函数源于c++中的类继承，是多态的一种。在c++中，一个基类的指针或者引用可以指向或者引用派生类的对象。同时，派生类可以重写基类中的成员函数。这里“重写”的要求是函数的特征标（包括参数的数目、类型和顺序）以及返回值都必须与基类中的函数一致。如下所示：

    ```cpp
    class base
    {
    	int a,b;
    public:
    	void test(){ cout<<"基类方法！"<<endl; }
            virtual ~base(){}
    };

    class inheriter:public base
    {
    public:
    	void test(){ cout<<"派生类方法！"<<endl; }     //重写基类方法
    };
    ```
    可以在基类中将被重写的成员函数设置为 **虚函数，** 其含义是：当通过基类的指针或者引用调用该成员函数时，将根据**指针指向的对象**类型确定调用的函数，而非指针的类型。如下，是未将test()函数设置为虚函数前的执行结果：

    ```cpp
    base *p1=new base;
    base *p2=new inheriter;
    p1->test();                                      //输出“基类方法”
    p2->test();                                      //输出“基类方法”
    ```
    在将test()函数设置为virtual后，执行结果如下：

    ```cpp
    base *p1=new base;                               //p1指向base类
    base *p2=new inheriter;                          //p2指向inheriter类
    p1->test();                                      //输出“基类方法”
    p2->test();                                      //输出“派生类方法”
    ```
    如此，便可以将基类与派生类的同名方法区分开，实现多态。

    **说明：**

    1.只需将基类中的成员函数声明为虚函数即可，派生类中重写的virtual函数自动成为虚函数；

    2.基类中的析构函数必须为虚函数，否则会出现对象释放错误。以上例说明，如果不将基类的析构函数声明为virtual，那么在调用delete p2;语句时将调用基类的析构函数，而不是应当调用的派生类的析构函数，从而出现对象释放错误的问题。

    3.虚函数的使用将导致类对象占用更大的内存空间。对这一点的解释涉及到虚函数调用的原理：编译器给每一个包括虚函数的对象添加了一个隐藏成员：指向虚函数表的指针。虚函数表（virtual function table）包含了虚函数的地址，由所有虚函数对象共享。当派生类重新定义虚函数时，则将该函数的地址添加到虚函数表中。无论一个类对象中定义了多少个虚函数，虚函数指针只有一个。相应地，每个对象在内存中的大小要比没有虚函数时大4个字节（32位主机，不包括虚析构函数）。如下：

    ```cpp
    cout<<sizeof(base)<<endl;                        //12
    cout<<sizeof(inheriter)<<endl;                   //12
    ```
    base类中包括了两个整型的成员变量，各占4个字节大小，再加上一个虚函数指针，共计占12个字节；inheriter类继承了base类的两个成员变量以及虚函数表指针，因此大小与基类一致。如果inheriter多重继承自另外一个也包括了虚函数的基类，那么隐藏成员就包括了两个虚函数表指针。

    4.重写函数的特征标必须与基类函数一致，否则将覆盖基类函数；

    5.重写不同于重载。我对重载的理解是：同一个类，内部的同名函数具有不同的参数列表称为重载；重写则是派生类对基类同名函数的“本地改造”，要求函数特征标完全相同。当然，返回值类型不一定相同（可能会出现返回类型协变的特殊情况）。

    ### 2.虚基类

    在c++中，派生类可以继承多个基类。问题在于：如果这多个基类又是继承自同一个基类时，那么派生类是不是需要多次继承这“同一个基类”中的内容？虚基类可以解决这个问题。

    简而言之，虚基类可以使得从多个类（它们继承自一个类）中派生出的对象只继承一个对象。虚继承的写法如下：

    ```cpp
    class mytest:virtual public base
    {
    };
    ```
    base称为mytest类的虚基类。假设base还是另外一个类mytest2的虚基类，对于多重继承mytest和mytest2的子类mytest3而言，base的部分只继承了一次。如下：

    ```cpp
    class base
    {
    	int b;
    public:
    	virtual void test(){ cout<<"基类方法！"<<endl; }
    	virtual ~base(){};
    };

    class mytest:virtual public base
    {
    };

    class mytest2:virtual public base
    {
    };

    class mytest3:public mytest,public mytest2
    {
    };

    cout<<sizeof(mytest)<<endl;                  //输出12
    cout<<sizeof(mytest2)<<endl;                 //输出12
    cout<<sizeof(mytest3)<<endl;                 //输出16，若在base中添加一个int型成员，则输出20
    ```
    mytest类与mytest2类的大小为什么是12？这是因为它们在虚继承自base类后，添加了一个隐藏的成员——指向虚基类的指针，占4个字节。而base类本身占8个字节，因此它们的大小均为12。而对非虚继承而言，是不需要这样的一个指针的。而mytest3类的大小为sizeof(base)+sizeof(mytest-base)+sizeof(mytest2-base)，即16。

    **说明：**

    1.若一个类多重继承自具有同一个基类的派生类时，调用同名成员函数时会出现二义性。为了解决这个问题，可以通过作用域解析运算符澄清，或者在类中进行重新定义；

    2.继承关系可能是非常繁复的。一个类可能多重继承自别的类，而它的父类也可能继承自别的类。当该类从不同的途径继承了两个或者更多的同名函数时，如果没有对类名限定为virtual，将导致二义性。当然，如果使用了虚基类，则**不一定**会导致二义性。编译器将选择继承路径上“最短”的父类成员函数加以调用。该规则与成员函数的访问控制权限并不矛盾。也就是说，不能因为具有更高调用优先级的成员函数的访问控制权限是"private"，而转而去调用public型的较低优先级的同名成员函数。

    ### 3.纯虚函数

    若一个类的成员函数被声明为纯虚函数，则意味着该类是ABC(Abstract Base Class，抽象基类)，即只能被继承，而不能用来声明对象。纯虚函数通常需要在类声明的后面加上关键词“=0”。

    当然，声明为纯虚函数并不意味着在实现文件中不可对其进行定义，只是意味着不可用抽象基类实现一个具体的对象。


[^9]: # 02面向对象部分

    # 00面向对象设计

    ## 概念

    面向对象程序设计（Object-Oriented Programming，OOP）是一种新的程序设计范型。程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。

    面向过程程序设计范型是使用较广泛的面向过程性语言，其主要特征是：程序由过程定义和过程调用组成（简单地说，过程就是程序执行某项操作的一段代码，函数就是最常用的过程）。

    面向对象程序的基本元素是对象，面向对象程序的主要结构特点是：第一，程序一般由类的定义和类的使用两部分组成；第二，程序中的一切操作都是通过向对象发送消息来实现的，对象接收到消息后，启动有关方法完成相应的操作。  

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108869979.png)​

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108808933.png)​

    **对象**：描述其属性的数据以及对这些数据施加的一组操作封装在一起构成的统一体。对象可认为是数据+操作。

    **类**：类是具有相同的数据和相同的操作的一组对象的集合。

    消息传递：对象之间的交互。

    **方法：**对象实现的行为称为方法。

    面向对象程序设计的基本特征：抽象、封装、继承、多态。  

    # 01C++基础

    #### 命名空间

    ```c++
    #include<iostream>
    using namespace std;

    namespace AA//namespace 定义命名空间的关键字，主要作用：区分同一个作用域下的同名成员
    {
    	int a = 20;
    	//int* p = &a;
    };
    namespace BB
    {
    	int a = 30;
    };
    /*将原本同在全局区的a=20和a=30分别放入AA和BB命名空间中，实现了作用域的划分*/

    int main()
    {
    	int a = 10;

    	cout << a << endl;

    	//cout << *p << endl;

    	//:: ：作用域运算符，符号前面指明哪个作用域，符号后面指明作用域中的成员，
    	//		::符号前未指明时，默认代表是全局
    	//cout << ::a << endl;

    	cout << AA::a << endl;
    	cout << BB::a << endl;
    }

    ```
    ​

    ##### 命名空间知识点总结

    1. namespace 		 定义命名空间的关键字  
        主要作用：区分同一个作用域下的同名成员
    2. ::                          作用域运算符  
        符号前面指明哪个作用域，符号后面指明作用域中的成员，::符号前未指明时，默认代表是全局
    3. 使用命名空间的方法

        1. 显式的指定，

            ```cpp
            命名空间 :: 成员  
            ```
        2. 打开某一个命名空间

            ```cpp
            using namespace 已有的命名空间 ;
            ```

    				打开命名空间，命名空间中的就对外开放了

    ‍

    #### const修饰常量

    9.5 const修饰指针[^10]

    在C语言中，习惯使用#define来定义常量，例如#​​define PI 3.14，C++提供了一种更灵活、更安全的方式来定义常量，即使用const修饰符来定义常量。例如const float PI = 3.14；

    const可以与指针一起使用，它们的组合情况复杂，可归纳为3种：指向常量的指针、常指针和指向常量的常指针。  

    **指向常量的指针**：一个指向常量的指针变量。

    ```cpp
    const char* pc = "abcd";
    该方法不允许改变指针所指的变量，即
        pc[3] = ‘x';   是错误的，
    但是，由于pc是一个指向常量的普通指针变量，不是常指针，因此可以改变pc所指的地址，例如
        pc = "ervfs";
    该语句付给了指针另一个字符串的地址，改变了pc的值。

    ```
    **常指针**：将指针变量所指的地址声明为常量

    ```cpp
    char* const pc = "abcd";
    创建一个常指针，一个不能移动的固定指针，可更改内容，如
        pc[3] = 'x';
    但不能改变地址，如
        pc = 'dsff';  不合法

    ```
    **指向常量的常指针**：这个指针所指的地址不能改变，它所指向的地址中的内容也不能改变。

    ```cpp
    const char* const pc = "abcd";
    内容和地址均不能改变

    ```
    > 说明：
    >
    > 如果用const定义整型常量，关键字可以省略。即 const in bufsize = 100 与 const bufsize = 100等价；
    >
    > 常量一旦被建立，在程序的任何地方都不能再更改。
    >
    > 与#define不同，const定义的常量可以有自己的数据类型。
    >
    > 函数参数也可以用const说明，用于保证实参在该函数内不被改动。
    >

    ‍

    #### void指针

    void通常表示无值，但将void作为指针的类型时，它却表示不确定的类型。这种void型指针是一种通用型指针，也就是说任何类型的指针值都可以赋给void类型的指针变量。

    需要指出的是，这里说void型指针是通用指针，是指它可以接受任何类型的指针的赋值，但对已获值的void型指针，对它进行再处理，如输出或者传递指针值时，则必须再进行显式类型转换，否则会出错  

    ```cpp
        void* pc;
        int i = 123;
        char c = 'a';
        pc = &i;
    	cout << pc << endl;         //输出指针地址006FF730
    	cout << *(int*)pc << endl;  //输出值123
        pc = &c;
    	cout << *(char*)pc << endl; //输出值a

    ```
    #### 内联函数(inline)

    在函数名前冠以关键字`inline`​​​，该函数就被声明为**内联函数**。每当程序中出现对该函数的调用时，C++编译器使用函数体中的代码插入到调用该函数的语句之处，同时使用实参代替形参，以便在程序运行时不再进行函数调用。引入[内联函数](https://so.csdn.net/so/search?q=%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)主要是为了消除调用函数时的系统开销，以提高运行速度。

    1. inline ：定义内联函数的关键字，编译阶段进行替换，提高函数的运行效率
    2. 内联函数在第一次被调用之前必须进行完整的定义，否则编译器将无法知道应该插入什么代码
    3. 本质是代码的替换  
        相对于函数，调用次数比较多的时候，占用内存，空间换时间  
        使用内联函数是一种空间换时间的措施，若内联函数较长，较复杂且调用较为频繁时不建议使用
    4. 适用场景：代码量少，逻辑比较简单，存在while，for，do while不推荐作为内联函数
    5. inline是建议性关键字  
        递归函数、虚函数即使加了inline，也不会是内联函数
    6. **使用内联函数替代宏定义，能消除宏定义的不安全性**

    ```cpp
    #include<iostream>
    using namespace std;
    int add(int a, int b)
    {
    	return a + b;
    }

    #define ADD(A,B)  ((A)+(B))

    inline int Add(int a, int b)
    {
    	return a + b;
    }


    int main()
    {
    	int a = add(10, 20);
    	cout << a << endl;

    	a = ADD(100, 200);
    	cout << a << endl;

    	a = Add(1, 2);
    	cout << a << endl;

    	return 0;
    }
    ```
    #### 带有默认参数值的函数

    函数指定默认值（默认形参值）

    当进行函数调用时，编译器按从左到右的顺序将实参与形参结合，若未指定足够的实参，则编译器按顺序用函数原型中的默认值来补足所缺少的实参。

    ```C++
    #include<iostream>
    using namespace std;

    //有传入值，用传入的，没有用默认
    void fun3(int a, int b, int c = 30)
    {
    	cout << a << endl;
    	cout << b << endl;
    	cout << c << endl;
    }

    /*
    中间位置的变量定义默认值，会报错
    void fun3(int a, int b=30, int c )
    {
    	cout << a << endl;
    	cout << b << endl;
    	cout << c << endl;
    }

    */
    void fun4(int a, int b=20, int c = 100);//指定参数默认值，一般在函数声明时指定（而不是在定义时）


    int main()
    {
    	fun3(100, 200, 300);
        fun4(10,30);
    	return 0;
    }

    void fun4(int a, int b, int c)
    {
    	cout << a << endl;
    	cout << b << endl;
    	cout << c << endl;
    }
    ```
    ##### 结论

    1. 当函数的声明和定义分开写时，**指定参数默认值，一般在函数声明时指定**（而不是在定义时）
    2. **传值**的规则是，**从左到右依次传值，中间不可以有间断**。

        **指定默认值**的规则是，**从右往左依次指定，中间不可以中断**，所以只有中间位置的变量指定默认值，会报错。
    3. 调用函数时，有传入值，用传入的，没有用默认

    ‍

    #### 函数重载

    在C++中，用户可以重载函数。这意味着，在同一[作用域](https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020)内，只要函数参数的类型不同，或者参数的个数不同，或者二者兼而有之，两个或者两个以上的函数可以使用相同的函数名。

    函数的重载使得C++程序员对完成类以功能的不同函数可以统一命名，减少了命名所花的心思。在调用函数时，编译器会根据实参的类型、数量自动匹配对应类型函数。

    ```cpp
    #include<iostream>
    using namespace std;
    int add(int a, int b)
    {
    	return a + b;
    }
    int add(int a, int b,int c)
    {
    	return a + b + c;
    }
    double add(double a, double b)
    {
    	return a + b;
    }
    void fun(int a, char b)
    {}
    void fun(char b,int a)
    {}


    int main()
    {
    	int a = 10, b = 20;
    	double aa = 12.3, bb = 34.56;
    	cout << add(a, b) << endl;
    	cout << add(aa, bb) << endl;

    	return 0;
    }
    ```
    ##### 注意

    1. 函数重载：描述了多个函数的关系，

        1. 函数名相同，
        2. **参数列表（参数类型、数量、顺序）不同**，
        3. 对返回类型没有要求（可以相同，也可以不同，不在参数匹配考察之列）
    2. 函数的重载与带默认值的函数一起使用时，有可能引起二义性。

        ```cpp
        void Drawcircle(int r = 0, int x = 0, int y = 0);
        void Drawcircle(int r);
        Drawcircle(20);
        ```
    3. 在调用函数时，如果给出的实参和形参类型不相符，C++的编译器会自动地做类型转换工作。如果转换成功，则程序继续执行，在这种情况下，有可能产生不可识别的错误。

        ```cpp
        void f_a(int x);
        void f_a(long x);
        f_a(20.83);

        ```
    4. 是重定义，不是函数重载

        ```c++
        void fun1(int*)
        {}
        void fun1(int p[])
        {}
        ```

    ‍

    ###### 作用域标识符"::"

    命名空间[^11]

    通常情况下，如果有两个同名变量，一个是全局的，另一个是局部的，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。

    如果希望在局部变量的作用域内使用同名的全局变量，可以在该变量前加上“`::`​​”，此时`::value`​​代表全局变量value，“`::`​​”称为作用域标识符。

    ```cpp
    #include <iostream>
    using namespace std;

    int value;   //定义全局变量value

    int main() 
    {
    	int value;  //定义局部变量value
    	value = 100;
    	::value = 1000;
    	cout << "local value : " << value << endl;
    	cout << "global value : " << ::value << endl;
    	return 0;
    }

    ```
    #### 强制类型转换

    可用[强制类型转换](https://so.csdn.net/so/search?q=%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020)将不同类型的数据进行转换。例如，要把一个整型数（int）转换为双精度型数（double），可使用如下的格式：

    ```cpp
    int i = 10;
    double x = (double)i;
    或
    int i = 10;
    double x = double(i);

    ```
    以上两种方法C++都能接受，建议使用后一种方法。

    #### new和delete运算符

    程序运行时，计算机的内存被分为4个区：程序代码区、全局数据区、堆和栈。其中，堆可由用户分配和释放。C语言中使用函数`malloc()`​​和`free()`​​来进行动态内存管理。C++则提供了[运算符](https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020)​`new`​​和`delete`​​来做同样的工作，而且后者比前者性能更优越，使用更灵活方便。

    ```cpp
    指针变量名 = new 类型
        int *p;
        p = new int;
    delete 指针变量名
        delete p;

    ```
    下面对new和delete的使用再做一下几点说明：

    1. 用运算符new分配的空间，使用结束后应该用也只能用delete显式地释放，否则这部分空间将不能回收而变成死空间。
    2. 在使用运算符new动态分配内存时，如果没有足够的内存满足分配要求，new将返回空指针（NULL）。
    3. 使用运算符new可以为数组动态分配内存空间，这时需要在类型后面加上数组大小。

        ```cpp
        指针变量名 = new 类型名[下标表达式];
        int *p = new int[10];

        ```
        释放动态分配的数组存储区时，可使用delete运算符。

        ```cpp
        delete []指针变量名;
        delete p;

        ```

    4. new 可在为简单变量分配空间的同时，进行初始化

        ```cpp
        指针变量名 = new 类型名(初值);
        int *p;
        p = new int(99);
        ···
        delete p;

        ```

    ##### 比较malloc--free和new-delete：

    ```c++
    #include<iostream>
    using namespace std;
    int main()
    {
    	//c动态申请空间 动态：申请的空间大小可变
    	int* p1 = (int*)malloc(sizeof(int));
    	*p1 = 10; //赋值而不是初始化
    	cout << *p1 << endl;
    	free(p1);
    	p1 = NULL;

    	//----------------------
    	//cpp动态申请空间 new 关键字，后面放要申请的类型（不需要计算大小），返回对应类型的地址
    	int *p2=new int;
    	*p2 = 20;
    	cout << *p2 << endl;
    	delete p2;
    	p2 = NULL;

    	int *p3=new int(30);
    	cout << *p3 << endl;
    	delete p3;
    	p3 = NULL;

    	//申请一个数组
    	int *p4=new int[5];//new返回的数组是首元素的首地址
    	for (int i = 0; i < 5; i++)
    	{
    		p4[i] = i * 10;
    	}
    	for (int i = 0; i < 5; i++)
    	{
    		cout << p4[i] << " ";
    	}
    	delete[]p4;//回收数组时候，指针前面加[]
    	p4 = NULL;
    	cout << endl;

    	int* p5 = new int[5]();//申请空间并且 默认初始化
    	for (int i = 0; i < 5; i++)
    	{
    		cout << p5[i] << " ";
    	}
    	delete[]p5;
    	p5 = NULL;
    	cout << endl;

    	int* p6 = new int[5]{5,4,3,2,1};//申请空间并且 自定义初始化
    	for (int i = 0; i < 5; i++)
    	{
    		cout << p6[i] << " ";
    	}
    	delete[]p6;
    	p6 = NULL;
    	cout << endl;

    	return 0;
    }
    ```
    ##### malloc--free和new-delete的区别：

    1. malloc-free函数，需要头文件支持，new-delete关键字需要编译器的支持
    2. malloc申请空间需要传申请空间的大小（需要计算），new需要的是类型，根据类型自动计算所需要的空间大小，ma1loc返回的是泛型指针(void*)一般需要强转为我们所需要的类型，new返回对应类型的地址不需要强转。
    3. new申请空间可以指定初始化值，malloc不可以
    4. **new申请结构体、类对象可以自动调用构造函数，delete可以自动调用析构函数**

    ##### new常见的使用：

    ```C++
    struct AA
    {

    };

    int main ()
    {
    	int **p1=new int*;//new 整型指针
    	delete p1;
    	p1 = NULL;
    	 
    	int**p2=new int*[5];//new 整型指针数组
    	delete p2;
    	p2 = NULL;

    	int **p1=new int*;//new 整型指针
    	delete p1;
    	p1 = NULL;
    	 
    	int**p2=new int*[5];//new 整型指针数组
    	delete p2;
    	p2 = NULL;

    	int(**p3)[5] = new (int(*)[5]);//new 整型数组指针
    	delete p3;
    	p3 = NULL;

    	int (*p4)[3] = new int[2][3];//new 二维数组
    	delete[]p4;//delete数组，加[]
    	p4 = NULL;


    	AA *p5=new AA;
    	delete p5;
    	p5 = NULL;

    	int (*p4)[3] = new int[2][3];//new 二维数组
    	delete[]p4;//delete数组，加[]
    	p4 = NULL;


    	AA *p5=new AA;
    	delete p5;
    	p5 = NULL;
      
        return 0;
    }
    ```
    *重点：整型数组指针、多维数组*

    #### 引用

    **引用**（`reference`​​）是C++对C的一个重要扩充。变量的引用就是变量的别名，因此引用又称**别名**。

    ```cpp
    类型 &引用名 = 已定义的变量名
    ```
    引用与其所代表的变量共享同一内存单元，系统并不为引用另外分配存储空间。实际上，编译系统使引用和其代表的变量具有相同的地址。

    ```c++
    #include<iostream>
    using namespace std;

    int main()
    {
    	int a = 10;
    	int& b = a;//&在定义时，是引用含义，作用：对这个变量对应的空间起的别名
    	cout << a << " " << b << endl;
    	cout << &a<< " " << &b << endl;
    	a = 20;
    	cout << a << " " << b << endl;

    	//int&c=a;//必须定义就初始化
    	//int*p;//可以不初始化

    	int& c = a;//引用一旦定义（必须初始化）就不可更改
    	int d = 40;

    }
    ```
    ##### 注意

    1. 必须定义就初始化

        * 引用并不是一种独立的数据类型，它必须与某一种类型的变量相联系。在声明引用时，必须立即对它进行初始化，不能声明完成后再赋值。
        * 为引用提供的初始值，可以是一个变量或者另一个引用。
    2. 引用一旦定义（必须初始化）就不可更改
    3. 指针是通过地址间接访问某个变量，而引用则是通过别名直接访问某个变量。
    4. 对引用的进一步说明

        1. 不允许建立void类型的引用
        2. 不能建立引用的数组
        3. 不能建立引用的引用。不能建立指向引用的指针。引用本身不是一种数据类型，所以没有引用的引用，也没有引用的指针。
        4. 可以将引用的地址赋值给一个指针，此时指针指向的是原来的变量。  
            可以用const对引用加以限定，不允许改变该引用的值，但是它不阻止引用所代表的变量的值。

    ##### 引用作为函数参数、使用引用返回函数值

    ```cpp
    #include <iostream>
    using namespace std;

    void swap(int &a, int &b)
    {
    	int t = a;
    	a = b;
    	b = t;
    }

    int a[] = {1, 3, 5, 7, 9};

    int& index(int i)
    {
    	return a[i];
    }

    int main() 
    {
    	int a = 5, b = 10;
    	//交换数字a和b
    	swap(a, b);
    	cout << "a = " << a << " b = " << b << endl;
    	cout << index(2) << endl;   //等价于输出元素a[2]的值
    	index(2) = 100;             //等价于将a[2]的值赋为100;
    	cout << index(2) << endl;

    	return 0;
    }

    ```
    ##### 出现冲突

    ```c++
    #include<iostream>
    using namespace std;

    void fun(int a)
    {
    	cout << "void fun(int a) " << a << endl;
    }
    void fun(int& a)
    {
    	cout << "void fun(int &a) " << a << endl;
    }

    //定义函数指针!!!!!!!!!!!!!!!!!!!!!!!!!!!
    void (*p1)(int) = &fun;
    void (*p2)(int&) = &fun;


    int main()
    {
    	int a = 10;
    	int& e =a;
    	//局部化 解决冲突
    	void fun(int a);//出现冲突，把要调用的声明局部化，然后就会默认调用这个
    	fun(e);

    	//函数指针解决冲突
    	cout << endl;
    	(*p1)(e);
    	(*p2)(e);

    	return 0;
    }
    ```
    ##### 解决冲突的两种方法

    1. 局部化声明
    2. 函数指针![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108906324.png)​

        ‍

    ‍

    ‍

    [CSDN超细笔记](https://blog.csdn.net/weixin_44368437/article/details/117563488?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166778659716782395356479%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166778659716782395356479&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117563488-null-null.142^v63^control,201^v3^control_1,213^v1^control&utm_term=c%2B%2B&spm=1018.2226.3001.4187)

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108869979.png)​

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108808933.png)​

    **对象**：描述其属性的数据以及对这些数据施加的一组操作封装在一起构成的统一体。对象可认为是数据+操作。

    **类**：类是具有相同的数据和相同的操作的一组对象的集合。

    消息传递：对象之间的交互。

    **方法：**对象实现的行为称为方法。

    面向对象程序设计的基本特征：抽象、封装、继承、多态。  

    ‍

    ## bool

    ```C++
    #include<iostream>
    #include<windows.h>
    using namespace std;

    int main()
    {
    	
    	//typdef int BOOL;
    	BOOL b = TRUE;//#define TRUE 1   ,#define FALSE 0
    	cout << b << " " << sizeof(b) << endl;//1 4
    	
    	bool b = true;
    	b = false;//true和false是cpp中的关键字
    	cout << b << " " << sizeof(b) << endl;//1 1
    	
    	return 0;
    }
    ```
    ### B00L和bool的区别：

    1. bool,true,false为C+中提供的关键字，定义变量所需要的空间大小为1个字节
    2. BOOL是一个int的别名(typedef),定义变量所需要的空间大小为4个字节，TRUE,FALSE为宏分别替换了整形数字1和0

    ## string

    ```c++
    #include<iostream>
    #include<string>//cpp字符串头文件，在比较新的版本中，iosteam中已经包含了string 
    using namespace std;

    int main()
    {

    	string str1 = "1234";
    	str1[1] = '9';
    	cout << str1 << endl;
    	str1 = "4321";
    	cout << str1 << endl;
    	string str2 = "4321";
    	if (str1 == str2)//string类型的可以直接比较变量名，而char a[]是不可以的，因为变量名是地址
    	{
    		cout << "相同" << endl;
    	}
    	else
    	{
    		cout << "不相同" << endl;
    	}
      
    	for (int i = 0; i < str1.size(); i++)//变量名.size()  可以获得字符串的长度
    	{
    		cout << str1[i] << "  ";
    	}
      
    	cout << str1.size() << endl;
    	cout << str1.length() << endl;//size()和length没有区别
      
        char* p="12345"
        cout << strlen(p) << endl;//strlen是返回char型字符串的函数
    	return 0;
    }
    ```
    ### 注意

    1. string类型的可以直接比较变量名，而char a[]是不可以的，因为变量名是地址
    2. 变量名.size() **方法**可以获得字符串的长度
    3. 变量名.size() 和变量名.length() 没有区别
    4. **区分:**strlen是返回char型字符串的函数

    ### string的方法

    ```C++
    //string拼接
    	string str3 = "123";
    	string str4 = str3 + "456";
    	cout << str4 << endl;
    	str4 += "99";
    	cout << str4 << endl;

    //string截取
    	string str5 = "123456789";
    	string str6 =str5.substr(2,4);//截取字串,从2（#开始下标#）开始，截取4（#长度#）个
    	/*
    	当长度越界时，会合理优化
    	当开始下标超限时，会报错
    	*/
    	cout << str6 << endl;

    //字符串转换
    	const char *pp=str5.c_str();//将里面存储的字符串转换成const char*,-->适配c中已有的函数等
    	cout << *pp << endl;
    ```
    #### 要点

    1. string拼接

       支持**+&quot;123&quot;**、**+char*字符串**、**+=**
    2. string截取

       **string类型变量名.substr(开始下标,截取长度);**

       1. 当长度越界时，会合理优化
       2. 当开始下标超限时，会报错
    3. 字符串转换

       **string类型变量名.c_str();**

       将里面存储的字符串转换成const char*

       作用：适配C语言中已有的函数等

    ## 增强型的for

    ```c++
    #include<iostream>
    using namespace std;
    int main()
    {
    	int arr[5] = { 1,2,3,4,5 };
        
    	for (int j = 0; j < 5; j++)
    	{
    		cout << arr[j] << " ";
    	}
    	cout << endl;
    	
        //增强型的for
    	for (int a : arr)
    	{
    		cout << a << " ";
    	}
    	cout << endl;
        
    	//增强型的for不能遍历new出来的
        
        //增强型的for能遍历str
    	string str("abcdefg");
    	for (char a : str)
    	{
    		cout << a << " ";
    	}
    	cout << endl;
    	
    	return 0;
    }
    ```
    ### 总结

    增强的for循环这种遍历方式，适用于普通的数组、string、和支持begin, end操作的容器等

    ## nullptr

    ```c++
    #include<iostream>
    using namespace std;

    void fun(int a)
    {
    	cout << "void fun (int a) " << a << endl;
    }

    void fun(int *p)
    {
    	cout << "void fun (int *p) " << p << endl;
    }

    void fun(char* p)
    {
    	cout << "void fun (int *p) " << p << endl;
    }


    int main()
    {
    	int* p = NULL;		//初始化为空，#define NULL 0
    	fun(NULL);			//实际传过去的是 0，匹配的是 void fun(int a)
    	fun((int*)NULL);	//传过去的才是NULL的地址，匹配的是 void fun(int *p)
    	fun(10);
    	//------------------------------------------------
    	nullptr;//c++提供的关键字，具有明确的含义：空指针
    	/*
    		fun(nullptr);//传过去的是 空指针 ，匹配的是 void fun(int *p)
    		但是，当void fun(int *p)和void fun(char *p),同时存在时，匹配不明确，会出现歧义
    	*/
    	//所以只能强转
    	fun((int*)nullptr);		//匹配void fun(int *p)
    	fun((char*)nullptr);	//匹配void fun(char *p)

    	fun((int*)NULL);		//匹配void fun(int *p)
    	fun((char*)NULL);	//匹配void fun(char *p)

    	return 0;
    }
    ```
    c++提供的关键字，具有明确的含义：空指针

    *个人理解：nullptr是NULL的升级而不是扩展，所以可以使用nullptr直接取代NULL*

    ## ​​实参传递

    ```c++
    #include<iostream>
    using namespace std;


    //void fun2(int a)//值传递
    //{
    //	a += 10;
    //	cout << a << endl;
    //}
    void fun2(int* p)//地址传递
    {
    	*p += 10;
    	cout << *p << endl;
    }
    void fun2(int& a)//引用传递
    {
    	a += 10;
    	cout << a << endl;
    }

    int main()
    {
    	
    	//fun2(aa);
    	int bb = 10;
    	fun2(&bb);
    	cout << bb << endl;
    	int cc = 10;
    	fun2(cc);
    	cout <<cc<< endl;

    	return 0;
    }
    ```
    ## 三种传递的比较

    |方法|值传递|地址传递|引用传递|
    | --------| --------------------------| ----------------------------------| ----------------|
    |代码风格|void fun(int a)|void fun(int* p)|void fun(int &a)|
    |调用方法|fun(num);|fun(&num);|fun(num);|
    |空间利用|将实参赋值一份，占空间较大|生成一个地址，占用空间较小（可控）|占用空间最小|
    |**能否**修改实参|不能|能|能|

    ## 友元函数

    注意

    1. 友元函数是**独立于当前类的外部函数**，
    2. 一个友元函数**可以同时定义为两个类的友元函数**
    3. 友元函数既可以在类的内部，也可以在**类的外部定义**；
    4. **在外部定义友元函数时，不必加关键字friend**
    5. **友元关系不能被继承**，基类的友元对派生类没有特殊的访问权限。

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1664032312261.png)​

    ‍

    # 02类基础

    ## 类的构成

    类声明中的内容包括数据和函数，分别称为数据成员和成员函数。按访问权限划分，数据成员和成员函数又可分为共有、保护和私有3种。

    ```cpp
    class 类名{
        public：
            公有数据成员；
            公有成员函数；
        protected:
            保护数据成员；
            保护成员函数；
        private:
            私有数据成员；
            私有成员函数；
    };

    ```
    #### 注意

    1. 类名一般大写C开头
    2. 类成员属性一般以 m_ + 数据类型 + 变量名
    3. 定义一个对象（类的实例化）,这时才会为对应的这个类开辟空间

    对一个具体的类来讲，类声明格式中的3个部分并非一定要全有，但至少要有其中的一个部分。一般情况下，一个类的数据成员应该声明为私有成员，成员函数声明为共有成员。这样，内部的数据整个隐蔽在类中，在类的外部根本就无法看到，使数据得到有效的保护，也不会对该类以外的其余部分造成影响，程序之间的相互作用就被降低到最小。  

    * 类声明中的关键字private、protected、public可以任意顺序出现。
    * 若私有部分处于类的第一部分时，关键字private可以省略。这样，如果一个类体中没有一个访问权限关键字，则其中的数据成员和成员函数都默认为私有的。
    * 不能在类声明中给数据成员赋初值。

    ```c++
    #include<iostream>
    #include<string>
    using namespace std;

    class CPeople{//类名一般大写C开头
    public:
    	string m_strName;//类成员属性一般以 m_ + 数据类型 + 变量名
    	bool m_bSex;
    	int m_nAge;

    	void run() {
    		cout << m_strName << "在跑步" << endl;
    	}
    };


    int main()
    {
    	CPeople peo;//定义一个对象（类的实例化）,这时才会为CPeople这个类开辟空间
    	peo.m_strName = "小明";
    	cout << peo.m_strName << endl;


    	return 0;
    }
    ```
    ## 访问修饰符

    ```c++
    class CPeople{//类名一般大写C开头
    	/*
    	访问修饰符(3种)：描述了类中的成员的适用范围，即访问控制（访问权限）
    	pub1ic:修饰的成员在类内、类外只要能定义对象的地方都可以使用，
    	protected::修饰的成员在类内和继承中的子类中可以使用。
    	private:修饰的成员只能在类内去使用。
    	*/
    public:
    	string m_strName;//类成员属性一般以 m_ + 数据类型 + 变量名
    protected:
    	bool m_bSex;
    private:
    	int m_nAge;
    public:
    	void run() {
    		cout << m_strName << "在跑步" << endl;
    	}
    	//---公共接口------
    	/*
    	公共接口存在的意义，可以在对类内私有数据做修改时，进行限制，避免随意修改
    	*/
    	int GetAge()
    	{
    		return m_nAge;
    	}
    	void SetAge(int num)
    	{
    		if (num >= 0 && num <= 200)
    		{
    			m_nAge = num;
    		}
    	}
    };

    int main()
    {
    	CPeople peo;//定义一个对象（类的实例化）,这时才会为CPeople这个类开辟空间
    	peo.m_strName = "小明";
    	cout << peo.m_strName << endl;
    	peo.SetAge(20);
    	cout << peo.GetAge() << endl;

    	return 0;
    }
    ```
    #### 访问修饰符描述

    	*描述了类中的成员的适用范围，即访问控制（访问权限）*

    1. **public**:修饰的成员在类内、类外只要能定义对象的地方都可以使用，
    2. **protected**::修饰的成员在类内和继承中的子类中可以使用。
    3. **private**:修饰的成员只能在类内去使用。

    # 03对象

    ## 对象种类

    ### 全局对象（例如：全局的CTest tst；)

    1. **生命周期**，从程序创建开始（在主函数执行前就会创建对象），一直到程序退出
    2. **作用域**：整个应用程序（可跨文件使用）

    ### 静态全局（例如：全局的static CTest tst2;)

    1. **生命周期**，从程序创建开始（在主函数执行前就会创建对象），一直到程序退出
    2. **作用域**：具有文件作用域，可以在当前文件中直接使用，跨源文件不能直接使用。

    ### 静态局部对象（例如：局部的/函数内的static CTest tst2;)

    1. 第一次调用该函数且执行了定义对象的代码，才会别创建，一直到程序退出
    2. 多次调用函数，并不会创建多个静态局部对象
    3. 在当前函数范围内可以直接使用，出了当前函数就不能直接使用了。出了函数外，可以通过对应的**指针**，间接使用静态局部

    ## 类的成员

    ### 类所占据的空间

    空类中1个字节，占位作用，标识当前对象真实存在与内存空间中，区别于其他对象。

    有成员属性后，按照属性所占空间分配。

    ### 成员属性和成员函数

    1. 一般的成员属性：属于对象，会占用对象的内存空间，定义对象的时候，定义多个对象会存在多份成员属性
    2. 成员函数：属于类的，占用的是应用程序的空间，编译期存在，一个类只有一份，与是否定义对象无关，多个对象共享函数

    ||所属|所占空间|份数|
    | :-------| :---| :-------| :---------------------------------------------------|
    |成员属性|对象|对象|与定义的对象数相关|
    |成员函数|类|应用程序|一个类只有一份，与是否定义对象无关，多个对象共享函数|

    ```c++
    #include<iostream>
    using namespace std;

    class CTest {
    public:
    	int m_a;
    	CTest() {
    	}
    	void show() {
    		cout << "shuow" << endl;
    	}
    	void showA() {
    		cout << "shuow" << " "<<m_a << endl;
    	}
    };

    int main()
    {
    	cout << sizeof(CTest) << endl;//空类 1个字节（占位标识符），有成员属性后，按照属性所占空间分配
        
    	CTest* p = nullptr;
    	//cout << p->m_a << endl;类不具体化成对象时，类中的成员属性并不存在，所以会报错
    	p->show() ;//类中的成员函数，存在，并且在 具体化对象后 也不占用对象的空间
    	//p->showA();//函数中用到了属性，所以也会出错

    	return 0;
    }
    ```
    ## this指针

    1. 类中的**非静态****成员函数**会有一个隐藏的参数，为this指针，这才是实际上该函数的第一个参数
    2. this指针的**作用**：连接当前调用该函数的对象和函数，在函数中使用其他成员都是使用this调用的

       **起桥梁作用，在类中可以无感知的使用类成员（成员属性、成员函数）**
    3. 编译器会默认为我们添加this指针

    ```c++
    #include<iostream>
    using namespace std;

    class CTest {
    public:
    	int m_a;
    	CTest() {

    	}
    	void show() {
    		cout << "shuow" << endl;
    	}
    	//类中的非静态成员函数会有一个隐藏的参数，为this指针，这才是实际上该函数的第一个参数
    	//this指针的作用：连接当前调用该函数的对象和函数，再函数中使用其他成员都是使用this调用的
    	void showA(/*CTest * const this */) {
    		cout << "shuow" << " "<<m_a << endl;//等效下面一行，编译器自动添加了 this
    		//cout << "shuow" << " "<<this->m_a << endl;
    		show();//等效于
    		//this->show();
    	}
    };

    int main()
    {
    	cout << sizeof(CTest) << endl;//空类 1个字节（占位标识符），有成员属性后，按照属性所占空间分分配
        
    	CTest* p = nullptr;
    	//cout << p->m_a << endl;类不具体化成对象时，类中的成员属性并不存在
    	p->show() ;//类中的成员函数，存在，并且不占用对象的空间
    	//p->showA();//函数中用到了属性，所以也会出错

    	return 0;
    }
    ```
    ## 静态成员(static)

    ### 静态成员初始化

    类中的静态成员初始化，需要写在类外，格式  类型 类名:: 变量名 = 初始化值  注意：去掉static  
    分文件编写的时候，写在.cpp中

    ```c++
    #include<iostream>
    using namespace std;

    /*
    静态成员属性：属于类，，不包含在对象的内存空间中，编译期存在，与对象存在与否无关
    */
    class CTest {
    public:
    	static int m_a;//静态成员属性
    	int m_b;
    	CTest() {
    		m_a = 10;//赋值，不是初始化
    		m_b = 20;//初始化
    		cout << m_a << endl;
    	}
        static void fun(){/*没有隐藏的指针this，就不能使用普通成员属性和成员函数*/
    		cout << "static void fun()" << endl;
    	}
    };
    /*
    类中的静态成员初始化，需要写在类外，格式  类型 类名:: 变量名 = 初始化值  注意：去掉static
    分文件编写的时候，写在.cpp中
    */
    int CTest::m_a = 30;//初始化

    /*
    静态成员的使用，可以通过对象也可以不通过对象
    */
    int main()
    {
    	CTest tst1;
    	cout << tst1.m_a << endl;
    	cout<<CTest::m_a;	//在没有对象的情况下，类名作用域直接使用
    	CTest tst2;
    	cout << &tst1.m_a << " " << &tst2.m_a << endl;

    	//通过对象去修改静态成员属性，对其他对象是可见的（使用的是修改之后的值）
    	tst1.m_a = 100;
    	cout << tst2.m_a << endl;

    }
    ```
    ### 静态成员属性

    1. 特点

       属于类的，不包含在对象的内存空间中，编译期存在，与对象存在与否无关，一个类中只有一份，多个对象共享
    2. 初始化

       需要写在类外进行初始化，格式类型类名：：变量名=初始化值，注意：去掉关键字static
    3. 调用

       可以通过对象去使用，也可以不通过对象类名作用域直接使用

    ### 静态成员函数

    1. 特点

       属于类的，在编译期存在，一个类只有一份，多个对象共享这一份函数

    ### 和普通的成员函数区别：

    1. 本质区别

       静态成员函数没有隐藏的this指针，就不能使用普通成员属性和成员函数，只能使用静态的成员。
    2. 调用

       静态成员函数是否通过对象都可以调用，普通的成员函数必须通过对象去调用。

    ## 常量指针和指针常量

    ### 定义

    ```c++
    #include<iostream>
    using namespace std;
    int main()
    {
    	int m_a = 10;
    	const int m_b = 20;

    	//常量指针,通过指针 值不课改，可改指向
    	const int* p1 = &m_a;//或者 int congst * p1 =&m_a;
    	//*p1 = 30;非法操作
    	p1 = &m_b;

    	//指针常量， 通过指针 值可改，指向不可改
    	int* const p2 = &m_a;//初始化必须赋值
    	*p2 = 40;
    	//p2 = &m_b;非法操作


    	//常量指针常量,不能修改指向，！不能通过！指针改值
    	const int* const p3 =& m_a;
    	//*p3=100;
    	//p = &m_b;
    	m_a = 100;//合法

    }
    ```
    ### 常量指针和指针常量的比较

    |类型|格式|值|指向|特点|
    | ------------| ---------------------------------------------------------| ------| ------| --------------------|
    |常量指针|const int* p1 ;//或者int const * p1;<br />const int* p1 = &m_a;|不可改|可改||
    |指针常量|int* const p2 = &m_a;|可改|不可改|创建的时候就要初始化|
    |常量指针常量|const int* const p3 =& m_a;|不可改|不可改||

    ### 指针安全级别问题

    ```c++
    const int*p3=&ma;//安全级别升级的操作

    int* const p4 = &mb; // &mb = const int*, 指针的安全级别是降级操作，不允许

    *p4=60;
    ```
    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108934482.png)

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108948399.png)

    ## 常函数

    ```c++
    #include<iostream>
    using namespace std;

    class CTest {
    public:
    	int m_a;
    	const int m_b;
    	static int m_c;

    	CTest():m_a(10), m_b(20) {
    	}
    	void show(/*CTest const this */) {
    		this->m_a = 40;
    		fun();
    		//或者this->fun();
    		
    		/*相当于
    		CTest tst;
    		CTest* const pthis2 =& tst;
    		const CTest* const pthisl = pthis2; // 指针的安全级别升级操作，允许的
    		*/
    	}
    	
    	/*
    	区别：this指针类型不同，对于常函数来说有双重const修饰，在常函数中不能修改类中的非静态成员属性，
    	常含数不能调用普通函数，但是可以调用静态函数
    	*/


    	/*常函数，在参数列表后面加const, const修饰了* this, 意味着this指针指向的对象里的成员属性不能修改*/
        
    	/*const */void fun(/*const CTest*const this *//*const int a*/)const {
    		cout << m_a << " " << m_b << endl;
    		// ma = 30;//即使是变量也不能在常函数中修改
    		//mb=40:
    		//this->m_a=20;不可修改
    		this->m_a;
    		this->m_b;

    		m_c = 50;//可以修改静态成员，因为静态成员可以不用this调用

    		//this->show();
    		//show();
    		
    		/*相当于
    		CTest tst;
    		const CTest*const pthisl =&tst;
    		CTest*const pthis2 pthis1://指针的安全级别降级操作，不允许
    		*/
    	}
    };
    int CTest::m_c = 30;

    int main()
    {
    	//int m_a = 10;
    	//const int m_b = 20;

    	//const int*p3=&ma;//安全级别升级的操作
    	// int* const p4 = &mb; // &mb = const int*, 指针的安全级别是降级操作，不允许
    	//*p4=60;

    	
    	return 0;
    }
    ```
    ### 特点

    1. 常函数，**在参数列表后面加const**, const修饰了* this, 变成了   `const CTest*const this`   意味着this指针指向的对象里的成员属性不能修改，即使是变量也不能在常函数中修改。
    2. 与普通函数的区别：this指针类型不同，对于常函数来说有双重const修饰，在常函数中不能修改类中的非静态成员属性，**常含数不能调用普通函数，但是可以调用静态函数（因为静态成员可以不用this调用）**
    3. **分文件编写时候，定义时，const不能省略**

    # 04继承

    ## 类之间的关系

    类之间的横向关系

    ### 组合（复合）

    它是一种"is a part of"的关系，部分与整体，包含与被包含。组合是一个类中包含另一个类对象。相比聚合，组合是一种强所属关系，**组合关系的两个对象往往具有相同的生命周期**，被组合的对象是在组合对象创建的同时或者创建之后创建，在组合对象销毁之前销毁。一般来说被组合对象不能脱离组合对象独立存在，整体不存在，部分一定不存在。

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E5%90%88.png)

    举例：人与手、人与头之间的关系，人需要包含头和手，头、手是人的一部分且不能脱离人独立而存在。
    在C+语法中，通常在组合类中包含被组合类对象来实现组合关系：

    ```c++
    class CHand{};
    class CPeople{
    	CHand m hand;//组合（复合）关系
    }
    ```
    ### 依赖

    它是一种"use a"的关系。一个对象的某种行为依赖于另一个类对象，被依赖的对象视为完成某个功能的工具，并不持有对他的引用，只有在完成某个功能的时候才会用到，而且是必不可少的。**依赖之间是没有生命周期约束关系的。**

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/image-20220826170956737.png)

    举例：人要完成编程这件事，那么需要用到电脑，电脑作为一个工具，其他的时候不需要，电脑也不可能作为人的属性而存在（非组合关系），人必须依赖于电脑才能完成编程这件事。
    C++语法中，代码的表现形式为多种，通常将被依赖的对象作为另一类方法的参数的形式实现两个类之间的依赖关系。

    ```c++
    class CComputer{};
    class CPeople{
    	void Code(CComputer *pc)//或：CComputer &pc,
    };
    ```
    ### 关联

    它是一种"has a"的关系。关联不是从属关系，而是**平等关系，可以拥有对方，但不可占有对方**。完成某个功能与被关联的对象有关，但是可有可无。**被关联的对象与关联的对象无生命周期约束关系**，被关联对象的生命周期由谁创建就由谁来维护。只要二者同意，可以随时解除关系或是进行关联，被关联的对象还可以再被别的对象关联，所以关联是可以共享的。

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/image-20220826171034226.png)

    举例：人和朋友的关系，人要完成玩游戏这个功能，没有朋友可以自己玩游戏，如果交到朋友了就可以和朋友一起玩游戏。
    C++语法中，通常在关联的类中定义被关联类对象的指针形式实现两个类之间的关联关系。

    ```c++
    class CFriend{};
    class CPeople{
    	CFriend*m pFriend;//关联关系
    }
    ```
    ### 聚合

    它是一种"owns a"的关系。多个被聚合的对象聚集起来形成一个大的整体，聚合的目的是为了统一进行管理同类型的对象，**聚合是一种弱所属关系**，**被聚合的对象还可以再被别的对象关联**，所以**被聚合对象是可以共享的**。虽然是共享的，聚合代表的是一种更亲密的关系，相当于强版本的关联。

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/image-20220826171052974.png)

    举例：一堆人组成一个家庭，进行统一管理完成敲代码工作。
    C++语法中，通常在聚合类中定义被聚合对象指针的数组、链表等容器。

    ```c++
    class CPeople{};
    class CFamily{
    	CPeople*m_pFamily [10];
    }
    ```
    ### 代码

    ```c++
    #include<iostream>
    using namespace std;


    class CHand {
    public:
    	void move() {
    		cout << "我的手在移动" << endl;
    	}
    };
    class CComputer {
    public:
    	void compile() {
    		cout << "电脑正在编译代码   生成可执行程序" << endl;
    	}
    };

    class CFriend {
    public:
    	void play() {
    		cout << "我的朋友正在玩耍" << endl;
    	}
    };


    class CPeople {
    public:
    	CHand m_hand;
    	CFriend* m_pFri;
    public:
    	void clap() {
    		m_hand.move();
    		cout << "手掌撞击   发出掌声" << endl;
    	}
    	void code(CComputer* pCom) {
    		if (pCom) {
    			m_hand.move();
    			cout << "敲出一行行代码...." << endl;
    			pCom->compile();
    		}
    		else {
    			cout << "我无法完成敲代码的功能" << endl;
    		}
    	}
    	void palyWangZhe() {
    		if (m_pFri) {//有朋友
    			cout << "找朋友组队.." << endl;
    			m_pFri->play();
    			cout << "我和我的朋友一起打王者，victory" << endl;
    		}
    		else {//没朋友
    			cout << "我和自己打王者，victory" << endl;
    		}
    	}
    };


    class CFamily {
    public:
    	CPeople* m_arrPro[10];
    	CFamily() {
    		for (CPeople*& peo : m_arrPro) {
    			peo = nullptr;
    		}
    		m_arrPro[0] = new CPeople;
    		m_arrPro[1] = new CPeople;
    		m_arrPro[2] = new CPeople;
    	}
    	~CFamily() {
    		for (CPeople*& peo : m_arrPro) {
    			if (peo) {
    				delete peo;
    				peo = nullptr;
    			}
    		}
    	}
    public:
    	void AllPeopleCode(CComputer* pCom) {
    		for (CPeople* peo : m_arrPro) {
    			if (peo) {
    				peo->code(pCom);
    			}
    		}
    	}
    };



    int main()
    {
    	{
    		//组合
    		CPeople peo;
    		peo.clap();
    		cout << endl;
    	}

    	{
    		//依赖
    		CComputer* pCom = new CComputer;
    		CPeople peo;
    		peo.code(pCom);

    		delete pCom;//回收电脑
    		pCom = nullptr;


    		peo.code(pCom);//此时没有电脑
    	}

    	{
    		//关联
    		CPeople peo;
    		peo.palyWangZhe();

    		CFriend* pFri = new CFriend;
    		peo.m_pFri = pFri;//结交朋友
    		peo.palyWangZhe();

    		peo.m_pFri = nullptr;//和朋友绝交
    		peo.palyWangZhe();

    		delete pFri;
    		pFri = nullptr;


    	}

    	{
    		//聚合
    		CComputer comp;
    		CFamily fam;
    		fam.AllPeopleCode(&comp);
    	}

    	return 0;
    }
    ```
    ## 类的继承

    ### 定义

    子类包含且可以使用父类的成员

    ```c++
    #include <iostream>
    using namespace std;
    //继承：子类包含且可以使用父类的成员
    class CFather {
    public:
    	int m_a;
    	int m_money;
    	CFather() {
    		m_money = 100;
    	}
    	
    };

    class CSon :public CFather {
    public:
    	int m_b;
    	int m_money;
    	CSon() {
    		m_a = 10;
    		m_b = 20;//子类可以直接使用父类的成员
    		m_money = 200;
    	}
    	void show() {
    		cout << m_a << " " << m_b << endl;
    		cout << CSon::m_money << endl;//当子类成员和父类成员同名时，在成员前面加上作用域得以区分，默认是子类
    		cout << CFather::m_money << endl;
    	}

    };

    int main()
    {
    	CSon p1;
    	p1.show();
    	cout << endl;
    	cout << p1.m_money << endl;
    	cout << p1.CSon::m_money << endl;
    	cout << p1.CFather::m_money << endl;//显示指定
    	return 0;
    }
    ```
    ### 子类与父类成员同名时

    当子类成员和父类成员同名时，在成员前面加上作用域得以区分（默认是子类）

    ### 当一个类包含另一个类的对象

    ```c++
    #include <iostream>
    using namespace std;
    class CStepFather {
    public:
    	int m_a;
    	CStepFather() {
    		m_a = 10;
    	}
    	CStepFather(int a) {
    		m_a = a;
    	}
    };

    class CSon {
    public:
    	CStepFather m_stepFa;//包含另一个类的对象
    	int m_son;
    public:
    	CSon() /*：m_stepFa() */ { // 当包含另一个类的对象，编译器会自动调用无参的构造进行初始化
    		m_son = 20;
    	}
    	CSon(int a) :m_stepFa(a) {//如果想调用带参数的构造函数进行初始化，需要手动显式指定
    		m_son = 20;
    	}
    	CSon(int a, int b) :m_stepFa(a) {
    		// 如果另一个类中没有无参的构造函数，必须显式的指定带参数的构造函数，如果什么也不指定，会报错
    		m_son = 20;
    	
    	}
    };



    int main() {
    	CSon son;
    	cout << son.m_son <<"  "<<son.m_stepFa.m_a << endl;
    	CSon son2(100);//匹配的是CSon和CStepFather的带参数的构造函数
    	cout << son2.m_son <<"   "<<son2.m_stepFa.m_a << endl;
    	return 0;
    }
    ```
    1. 当包含另一个类的对象，编译器会自动调用无参的构造进行初始化
    2. 如果想调用带参数的构造函数进行初始化，需要手动显式指定
    3. 如果另一个类中没有无参的构造函数，必须显式的指定带参数的构造函数，如果什么也不指定，会报错

    ### 继承中构造和析构的顺序

    #### 构造顺序

    真父类->假父类->子类

    #### 析构顺序

    **和构造的顺序相反**

    先析构在回收对象

    析构子类->回收子类---->析构假父类->回收假父类---->析构父类->回收父类

    ### 继承的优点

    继承的优点：将功能比较相似的类里面的公共的成员、方法等，单独抽离出来形成一个类，这个类就作为**父类**，各个子类继承这个父类，只维护了父类中的一份公共的代码，无论增加还是修改公共的方法，只需要修改一份即可，当增加新的子类只需要继承父类，这些公共的方法也就继承了也可以使用了，**提高了程序代码的复用性、扩展性，灵活性。**

    ## 继承方式

    public  、protected、private, 和 访问修饰符共同决定了父类中的成员在子类中的使用范围，所表现属性 及  访问控制

    ### 继承方式：public

    |父类成员属性|子类成员属性|
    | ------------| ------------|
    |public|public|
    |protected|protected|
    |private|不可访问|

    ### 继承方式：protected

    |父类成员属性|子类成员属性|
    | ------------| ------------|
    |public|protected|
    |protected|protected|
    |private|不可访问|

    ### 继承方式：private

    |父类成员属性|子类成员属性|
    | ------------| ------------|
    |public|private|
    |protected|private|
    |private|不可访问|

    ### 默认继承方式

    private私有继承

    ## 隐藏

    子类中出现和父类中同名的函数，会隐藏父类中的函数。这种关系叫**隐藏**。

    若想使用父类中的函数，可以**加上类名作用域**。

    ## 父类指针直接指向子类对象

    ```c++
    #include<iostream>
    using namespace std;

    void show(int a) {
    	cout <<"show(int a)" << a << endl;
    }

    void show(char a) {
    	cout << "show(char a)" << a << endl;
    }

    class A {
    public:
    	void show(/*  A * const this   */int a, int b) {  //和子类中同名的成员的关系可以称之为：隐藏
    		cout << "A::show(int a, int b) " << a << "    " << b << endl;
    	}
    };

    class AA:public A {
    public:
    	void show(int a) {
    		cout << "AA::show(int a)" << a << endl;
    	}
    	//也是函数重载
    	void show(char a) {
    		cout << "AA::show(char a)" << a << endl;
    	}
    };


    int main() {
    	show(10);   //可以根据实参自动匹配对应的重载函数
    	show('a');

    	/*AA aa;
    	aa.show(10);
    	aa.show('b');*/
    	
    	//aa.show(10,20);    //想去匹配父类的函数，但无法自动匹配，不是函数重载，因为不在一个作用域下
    	 
    	
    	//-----------------------------------
    	
    	//AA aa;
    	//aa.show(10, 20);  //子类的同名的函数注释掉，可以匹配父类的函数了

    	AA aa;
    	aa.A::show(10,20);   //显式指定父类的show函数

    	A* pthis = &aa;  //继承下，父类的指针不通过强转可以直接指向子类对象
    	//保证了用子类的对象可以成功的调用父类的非静态成员函数,
    	//除此之外，还可以利用这个特性：统一多种子类类型

    	return 0;
    }
    ```
    **继承下，父类的指针不通过强转可以直接指向子类对象**

    保证了用子类的对象可以成功的调用父类的非静态成员函数,
    除此之外，还可以利用这个特性：统一多种子类类型

    ## 调用函数的三种方法

    ```c++
    #include<iostream>
    using namespace std;

    /*
    函数指针的优点：函数指针可以指向不同模块但是功能相似的函数，利于系统抽象、降低耦合度，接口和函数分离，提高代码复用性、
    拓展性
    */

    void show() {
    	cout << "show()" << endl;
    }



    int main() {
    	show();	//函数名调用

    	void(*p)() = &show;x 
    	(* p)();//通过函数指针间接调用函数

    	typedef void(*P_FUN)();//优化函数指针
    	P_FUN p2 = &show;//void(*p2)() = &show;
    	(*p2)();
    }
    ```
    ## typedef优化函数

    ```c++
    typedef void (CPeople::* P_FUNN)();

    // P_FUNN  ==== void (CPeople::* )()

    void Show(CPeople* pPeo, P_FUNN p_fun) {
    	pPeo->Cost(20);
    	//pPeo->Eat();
    	(pPeo->*p_fun)();
    	pPeo->Play();
    }
    ```
    ## 类成员函数指针

    ```c++
    #include<iostream>
    using namespace std;
    void show() {
    	cout << "show" << endl;
    }
    class  CTest {
    public:
    	void show(/* CTest const this */) {
    		cout << "CTest::show" << endl;
    		cout << "this" << endl;
    	}

    };
    /*
    区别：
    1.作用域不同。
    2.非静态类成员函数有隐藏的this指针，全局的函数没有
    */

    int main() {

    	CTest tst;
    	tst.show();

    	//void (*p_fun)() = &tst.show;//这是一个错误的写法
    	//void (*p_fun)() = &CTest::show;//无法从“void(CTest ::*)(void)” 转换为 “void(*)(void)”
    	// 类成员函数指针，C ++ 中提供的一个整体操作  ::* ，用来定义类成员函数指针
    	
    	void (CTest :: * p_fun)() = &CTest::show;
    	(tst .* p_fun)();///.*、->*c+中提供的一个整体操作，通过对象调用类成员函数指针指向的类成员函数


    	CTest* pTst = new CTest;
    	(pTst->*p_fun)();

    	cout << pTst << endl;


    	return 0;


    }
    ```
    ## 使用类成员函数指针实现多态

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108978957.png)

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108990455.png)

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662109003719.png)

    # 05多态

    ## 多态

    ### 概念

    **多态**  
    多种形态，相同的行为导致了不同的结果，同一行语句展现了多种不同的表现形态，即多态  
    父类的指针可以指向任何继承于该类的子类对象，多种子类对象具有多种形态，由父类的指针统一管理，  
    父类的指针则具有多种形态，即是多态。

    ### 多态的条件

    1. 在**继承**下，父类指针指向子类对象（或者**引用**形式，如`CFather& fa = son; //引用形式的多态`​本质还是父类指针指向子类对象）
    2. 父类存在虚函数，子类重写虚函数

    ### 什么叫虚函数

    `virtual`虚函数关键词

    例如

    ```C++
    virtual void show() {
    		cout << "CFather::virtual void show()" << endl;
    	}
    ```
    ### 什么叫“重写”

    子类定义和父类虚函数一模一样(函数名，参数，返回类型)的虚函数。

    **virtual在父类虚函数必须写，在子类处可以不写**

    ```c++
    /*多态
    多种形态，相同的行为导致了不同的结果，同一行语句展现了多种不同的表现形态，即多态
    父类的指针可以指向任何继承于该类的子类对象，多种子类对象具有多种形态，由父类的指针统一管理，
    父类的指针则具有多种形态，即是多态。
    */

    /*多态的条件
    1. 在继承下，父类指针指向子类对象
    2.父类存在虚函数，子类重写虚函数
    */


    /*什么叫“重写”
    子类定义和父类虚函数一模一样(函数名，参数，返回类型)的虚函数
    */

    #include<iostream>
    using namespace std;
    class CFather {
    public://virtual虚函数关键词
    	virtual void show() {
    		cout << "CFather::virtual void show()" << endl;
    	}
    };

    class CSon :public CFather {
    public:
    	virtual void show() {
    		cout << "CSon::virtual void show()" << endl;
    	}
    };

    int main() {
    	CFather* pFa = new CSon;
    	pFa->show();
    	return 0;
    }
    ```
    ## 子类的虚函数列表

    继承多态下，子类的虚函数列表：

    1. 子类不但继承父类的成员，也会继承父类的虚函数列表。
    2. 会检查子类中是否有重写的父类的虚函数，如果有就原位置替换如果没有父类的虚函数得以保留。
    3. 子类中独有的虚函数，按照顺序依次在虚函数列表的后面添加。
    4. 覆盖：子类的虚函数列表中，子类虚函数会替换掉父类的虚函数（重写），这个动作称之为覆盖

    ```c++
    #include<iostream>
    using namespace std;


    class CFather {
    public:
    	virtual void fun1() {
    		cout << "CFather::fun1()" << endl;
    	}
    	virtual void fun2() {
    		cout << "CFather::fun2()" << endl;
    	}
    };

    class CSon :public CFather{
    public:
    	virtual void fun1() {
    		cout << "CSon::fun1()" << endl;
    	}
    	virtual void fun3() {
    		cout << "CSon::fun3()" << endl;
    	}
    };
    class CSon2 :public CFather {
    public:
    	virtual void fun1() {
    		cout << "CSon2::fun1()" << endl;
    	}
    };

    /*继承多态下
    *虚函数指针指向哪个类的虚函数在列表，取决于定义哪个类的对象（new哪个子类）
    */


    /*继承多态下，子类的虚函数列表：
    1.子类不但继承父类的成员，也会继承父类的虚函数列表。
    2.会检查子类中是否有重写的父类的虚函数，如果有就原位置替换
    如果没有父类的虚函数得以保留。
    3.子类中独有的虚函数，按照顺序依次在虚函数列表的后面添加。
    4. 覆盖：子类的虚函数列表中，子类虚函数会替换掉父类的虚函数（重写），这个动作称之为覆盖
    */
    int main() {
    	CFather* pFa1 = new CFather;//虚函数指针指向 父类CFather 的虚函数列表

    	CFather* pFa2 = new CSon;//虚函数指针指向 子类CSon 的虚函数列表
    	CFather* pFa3 = new CSon2;//虚函数指针指向 子类CSon2 的虚函数列表
    	

    	CSon son;
    	/*
    	[0]:CSon::fun1
    	[1]:CFather:fun2
    	*/
    	pFa2->fun1();
    	pFa2->fun2();
    	((CSon*)pFa2)->fun3();

    	return 0;
    }
    ```
    ### 注意

    继承多态下虚函数指针指向哪个类的虚函数列表，取决于定义哪个类的对象（new哪个子类）

    ### 特殊情况

    ```c++
    #include <iostream>
    using namespace std;

    class CFather
    {
    public:
        virtual void fun1()
        {
            cout << "Father::fun()1" << endl;
        }
        virtual void fun2()
        {
            cout << "Father::fun()2" << endl;
        }
    };

    class CSon : public CFather
    {
    public:
        virtual void fun1()
        {

            cout << "Son::Pfun()1" << endl;
        }

        virtual void fun3()
        {
            cout << "Son::fun()3" << endl;
        }
    };

    typedef void (*P_FUN)();

    int main()
    {
        CFather* pFa = new CSon;
        pFa->fun1();
        pFa->fun2();
        ((CSon *)pFa)->fun3();
        cout << endl;
        //------------------------------

        int a = *(int*)pFa; //_vptr
        P_FUN p_fun1 = (P_FUN)(((int*)a)[0]);
        P_FUN p_fun2 = (P_FUN)(((int*)a)[1]);
        P_FUN p_fun3 = (P_FUN)(((int*)a)[2]);
        (*p_fun1)();
        (*p_fun2)();
        (*p_fun3)();


        CSon son;
        CFather& fa = son; //引用形式的多态
        fa.fun1();
        fa.fun2();
        cout << 1 << endl;

        return 0;
    }
    ```
    当子类中有独属于子类的函数的时候，指向子类的父类指针就无法访问子类的这个成员函数。

    #### 解决方法

    1. 强转 `((CSon *)pFa)->fun3();`
    2. 手动模拟虚函数指针的方式访问。

       ```C++

       typedef void (*P_FUN)();

       int a = *(int*)pFa; //_vptr
           P_FUN p_fun1 = (P_FUN)(((int*)a)[0]);
           P_FUN p_fun2 = (P_FUN)(((int*)a)[1]);
           P_FUN p_fun3 = (P_FUN)(((int*)a)[2]);
           (*p_fun1)();
           (*p_fun2)();
           (*p_fun3)();
       ```
       注意：将指针强制转成int型只能在x86平台下（在x64平台下，用long接收），否则会出现**-Wint-to-pointer-cast**

    ## 虚函数

    注意

    分文件编写时，定义时，virtual不写

    ### 虚函数指针

    存在一个虚函数指针_vfptr，类型为`void**`
    属于对象的二级指针，在对象内存空间的首地址
    定义多个对象，虚函数指针会存在多份，但是多个对象的虚函数指针指向的是同一个地址（虚函数列表）

    _vfptr 是编译期 默认给加到类中的 成员属性，在定义对象时，在构造的初始化参数列表中由编译器自动进行初始化，指向虚函数列表

    #### 虚函数列表

    编译期存在，属于类，只有一份，为多个对象的虚函数所共用
    存放类中虚函数的地址的空间
    按照类中声明顺序排布，以数组的形式呈现，每个元素为虚函数的地址

    **必须由真实的类调用**

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662109105677.png)

    ### 虚函数的调用流程

    ​	1. 找到对象内存空间首地址指针大小的一块空间（_vfptr），
    ​	2. 通过它间接引用 找到虚函数列表（数组），
    ​	3. 通过下标定位匹配对应的虚函数地址，在通过这个地址调用虚函数。

    ### 普通函数的调用流程

    ​	通过函数名（即为函数的入口地址），然后直接跳转执行函数

    ### 虚函数和普通函数的区别

    ​	1. 本质区别：函数调用流程不同
    ​	2. 效率不同：普通函数性能强，虚函数性能弱
    ​	3. 使用场景不同：虚函数可以实现多态，普通函数不能

    ```c++
    #include<iostream>
    using namespace std;
    class CTest {
    public:
    	int m_a;
    	void fun() {//函数属于类，而不属于对象
    		cout << "CTest fun()" << endl;
    	}
    	/*_vfptr虚函数指针
    	 存在一个虚函数指针，类型为void**
    	 属于对象的二级指针，在对象内存空间的首地址
    	定义多个对象，虚函数指针会存在多份，但是多个对象的虚函数指针指向的是同一个地址（虚函数列表）
    	_vfptr 是编译期 默认给加到类中的 成员属性，在定义对象时，在构造的初始化参数列表中由编译器自动进行初始化，指向虚函数列表
    	*/
    	
    	/*虚函数列表
    	编译期存在，属于类，只有一份，为多个对象的虚函数所共用
    	存放类中虚函数的地址的空间
    	按照类中声明顺序排布，以数组的形式呈现，每个元素为虚函数的地址
    	*/


    	/*虚函数的调用流程
    	1. 找到对象内存空间首地址指针大小的一块空间（_vfptr），
    	2. 通过它间接引用 找到虚函数列表（数组），
    	3. 通过下标定位匹配对应的虚函数地址，在通过这个地址调用虚函数。
    	*/

    	/*普通函数的调用流程
    	通过函数名（即为函数的入口地址），然后直接跳转执行函数
    	*/

    	/*虚函数和普通函数的区别
    	1. 本质区别：函数调用流程不同
    	2. 效率不同：普通函数性能强，虚函数性能弱
    	3. 使用场景不同：虚函数可以实现多态，普通函数不能
    	*/

    	virtual void fun2() {
    		cout << "CTest virtual fun2()" << endl;
    	}

    	virtual void fun3() {
    		cout << "CTest virtual fun3()" << endl;
    	}
    };

    int main() {

    	//cout << sizeof(CTest)<<endl;//sizeof(类)得到的是类对应的对象的大小

    	//CTest tst;
    	//cout << &tst<< "   " << &tst.m_a << endl;

    	//CTest tst2;
    	//tst2.fun2();


    	//CTest* ptst = nullptr;
    	//ptst->fun();//空指针对象调用普通函数，虽然可以但是不推荐这样使用
    	//ptst->fun2();//空指针对象调用不了虚函数

    	//手动模拟虚函数调用
    	CTest* ptst2 = new CTest;
    	int a=*(int*)ptst2;

    	typedef void (*P_FUN)();
    	P_FUN p_fun1=(P_FUN)((int*)a)[0];
    	P_FUN p_fun2=(P_FUN)((int*)a)[1];


    	(*p_fun1)();//CTest virtual fun2()
    	(*p_fun2)();//CTest virtual fun3()
    	return 0;
    }
    ```
    ## 虚析构

    ```c++
    #include <iostream>
    using namespace std;

    class CFather
    {
    public:
        CFather()
        {
            cout << "CFather构造" << endl;
        }
        virtual~CFather()
        {
            cout << "CFather析构" << endl;
        }
    };

    class CSon : public CFather
    {
    public:
        int* m_p=nullptr;
        CSon()
        {
            cout << "CSon构造" << endl;
        }
        ~CSon()//在编译器角度，和父类的名字是相同的。可写可不写virtual
        {
            cout << "CSon析构" << endl;
            if (m_p)
            {
                delete m_p;
                m_p = nullptr;
            }
        }
    };

    /*
    父类指针指向子类对象：在回收空间时，子类的析构没有被执行，有可能（不是一定）会发生内存泄漏，
    父类的指针有效范围为父类，只能调用父类的析构函数，
    解决这个问题：虚析构
    发生多态行为，最终调用的是子类的析构函数，回收对象时，其中包函数父类的成员，回收父类成员前，会调用父类的析构。
    */

    int main()
    {
        //CSon son;

        CFather* pFa = new CSon;
        //pFa->~CFather();//可以
        //pFa->~CSon();//报错

        //delete (CSon*)pFa;//可以正确析构，但是不是一种好的方法


        pFa->~CFather();//调用虚析构函数，且子类的析构函数重写了父类的析构，实现了多态最终调用的是子类析构
        pFa = nullptr;

        
        return 0;
    }
    ```
    ### 问题/现象

    父类指针指向子类对象：在回收空间时，子类的析构没有被执行，有可能（不是一定）会发生内存泄漏，

    父类的指针有效范围为父类，只能调用父类的析构函数，

    ### 解决方法：虚析构

    由于子类重写了父类的析构函数，发生多态行为，最终调用的是子类的析构函数，回收对象时，其中包函数父类的成员，回收父类成员前，会调用父类的析构。

    ## 纯虚函数

    纯虚函数：格式 **类内** `virtual void fun() = 0;`

    ​		纯虚函数，子类必须重写。只在父类声明，不需实现

    包含纯虚函数的类不能实例化，又叫**抽象类**

    ```c++
    #include <iostream>
    using namespace std;

    class CFather//包含纯虚函数的类，不能实例化，又叫 抽象类
    {
    public:
        virtual void fun() = 0;//纯虚函数，子类必须重写。只在父类声明，不需实现
        
        virtual void fun1()
        {
            cout << "Father::fun()2" << endl;
        }
    };

    class CSon : public CFather//抽象类的派生类，又称 具体类
    {
    public:
        virtual void fun()
        {
            cout << "CSon::fun()" << endl;
        }
        virtual void fun1()
        {

            cout << "Son::Pfun()1" << endl;
        }
    };



    int main()
    {

        CFather* pFa = new CSon;
        pFa->fun();

        //CFather fa;//包含纯虚函数的类不能实例化，叫抽象类
        
        return 0;
    }


    ```
    |类|必备条件|特点|
    | --------| ----------------| --------------------------|
    |抽象类|有纯虚函数|不能实例化、子类**必须重写**纯虚函数|
    |具体类|不能有纯虚函数|可以实例化|

    ### 多态缺点：

    1. 效率：调用虚函数效率低。
    2. 空间：虚函数指针占用空间，多个对象会有多个虚函数指针，虚函数列表会随若继承的层级递增虚表大小只增不减。
    3. 安全：类中的私有的函数，不能为虚函数，否则会有安全隐忠。

    # 06分文件编写

    ## 头文件和源文件的区别

    1.使用区别：  
    头文件：变量、函数 的声明，类的定义，宏的定义...  
    源文件：变量的定义，函数定义实现，类中成员函数的定义实现，

    ## 注意事项

    1. 声明变量`extern int c;   //声明变量`
    2. 函数声明 `void fun();   //函数的声明`
    3. 构造、析构的声明

       ```c++
       CTest();   //构造的声明
       ~CTest();  //析构的声明
       ```
    4. 静态变量类外初始化，在.cpp文件中
    5. 类成员函数在.cpp文件中定义，含·函数名前加**类名作用域**
    6. 常量在源文件中的构造函数初始化参数列表中进行初始化

       ```c++
       CTest::CTest():m_a(5), m_b(20){  //常量在源文件中的构造函数初始化参数列表中进行初始化
       	cout << "CTest()   " << m_a << endl;
       	m_a = 10;
       	cout << "CTest()   " << m_a << endl;
       }
       ```
    7. static、virtual定义的时候关键字去掉
    8. const定义的时候保留
    9. 类模板
       类模板是泛型，与常规的不同，在编写的时候，不要分开。

    ## 头文件重复包含

    例如：

    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662109123858.png)

    BB.h和CC.h都包含的AA.h，main函数有都包含了BB.h和CC.h，就会出现AA.重复包含的问题

    ### 解决方案1

    在AA.h第一行加一句

    `#pragma once`

    #pragma once: 直接和编译器沟通，告诉编译器当前的头文件在其他源文件中，只包含一次，
    直接和编译器沟通 效率高，代码编译的速度快，不需要考虑宏重名的问题

    ### 解决方案2

    基于宏的逻辑判断，编译的速度慢，有一定的概率，宏的名字会重复，导致程序错误。

    ```c++
    #ifndef   __宏__   //判断当前宏是否定义，如果没定义的话,就定义宏#define
    #define   __宏__

    ...我的代码...

    #endif  //__宏
    ```
    # 07程序生成过程

    ## 程序生成过程（4个阶段）：

    ### 预处理：

    源代码文件 main.cpp -> main.i 预处理后的文件

    1.#include   头文件的展开
    2.删除注释
    3.#define 宏的替换。  
    4.#ifndef ,#ifdef ,#else #elif  #if  #endif...等预处理指令

    ### 编译阶段：

    将预处理后的文件进一步处理，生成汇编文件，包含汇编代码，  main.i  ->  main.asm(汇编文件)

    对代码进行 语法分析、语义分析、词法分析 和 优化

    ### 汇编阶段：

    将上一步生成的汇编文件，按照汇编代码一条一条生成目标机器指令，main.asm->main.obj(目标机器文件(二进制文件))

    ### 链接阶段：

    通过链接器将多个目标文件（.obj）和库文件 链接整合到一起，生成可执行程序（.exe（二进制文件））

    ## 编译期：

    将源代码文件交由编译器，编译、生成，最终生成可执行文件的过程。

    ## 运行期：

    将可执行文件交由操作系统运行，直到程序退出的过程。

    类编译期的概念，包括 访问修饰符 和 作用域，属于编译期的概念，
    对象（类的一个实例化）运行期的概念，包括指针，引用等

    ## 细节

    ```c++
    #include<iostream>
    using namespace std;

    /*
    * 程序生成过程（4个阶段）：
    预处理：源代码文件 main.cpp -> main.i 预处理后的文件
    1.#include   头文件的展开
    2.删除注释
    3.#define 宏的替换。
    4.#ifndef ,#ifdef ,#else #elif  #if  #endif...等预处理指令

    编译阶段：将预处理后的文件进一步处理，生成汇编文件，包含汇编代码，  main.i  ->  main.asm(汇编文件)
    对代码进行 语法分析、语义分析、词法分析 和 优化

    汇编阶段：将上一步生成的汇编文件，按照汇编代码一条一条生成目标机器指令，main.asm->main.obj(目标机器文件(二进制文件))


    链接阶段：通过链接器将多个目标文件（.obj）和库文件 链接整合到一起，生成可执行程序（.exe（二进制文件））


    编译期：将源代码文件交由编译器，编译、生成，最终生成可执行文件的过程。

    运行期：将可执行文件交由操作系统运行，直到程序退出的过程。

    类编译期的概念，包括 访问修饰符 和 作用域，属于编译期的概念，
    对象（类的一个实例化）运行期的概念，包括指针，引用等

    */

    class CFather {
    public:
    	virtual void fun() {
    		cout << "CFather::fun" << endl;
    	}
    };


    char arr[20] = { 0 };

    class CSon:public CFather {
    private:  //编译期的限制，多态是运行期多态，所以限制不住，能调用
    	virtual void fun() {
    		cout << "CSon::fun" << endl;
    	}
    private:
    	void fun2() {
    		cout << "CSon::fun2" << endl;
    	}

    public:
    	static void GetFun2() {
    		printf("%p  %d\n",&CSon::fun2, &CSon::fun2);

    		sprintf_s(arr,"%d", &CSon::fun2);
    		cout << arr << endl;
    	}
    };

    union AA {
    	int a;
    	void (*p_fun)();
    }aa;


    int main() {

    	/*const bool a = true;   //优化的例子
    	if (a) {
    		cout << "aa" << endl;
    	}*/

    //
    //	//编译期确定
    //#if __cplusplus
    //#define A   10
    //#else 
    //#define A   20
    //#endif //__cplusplus
    //
    //	int a = A;
    //	cout << a << endl;
    //
    //
    //	//运行期确定
    //	int b = 0;
    //	cin >> b;
    //	if (b == 10) {
    //		cout << "bbb" << endl;
    //	}
    //	else {
    //		cout << "aaa" << endl;
    //	}
    //
    //	//-------------------------------------
    //	//编译期错误
    //	//int len = 10;   //error C2131: 表达式的计算结果不是常数
        //int arr[len] = { 0 };
    //	//const int len = 9999999999999;
    //	//int arr[len] = { 0 };  //error C2148: 数组的总大小不得超过 0x7fffffff 字节
    //
    //	//运行期错误
    //	//int l = 9999999999999;
    //	int l = 9;
    //	int * p = new int[l];
    //	//p[20] = 0;  //数组越界，运行期错误
    //
    //	cout << "//---------------------------" << endl;
    //	CFather* pFa = new CSon;
    //	pFa->fun();   //CSon::fun


    	//----------------------------
    	CSon::GetFun2();

    	aa.a = atoi(arr);   //将十进制字符串转成数字
    	cout << aa.a << endl;
    	(*aa.p_fun)();

    	return 0;
    }
    ```
    ## 注意

    ### 宏是编译期

    ### 变量开数组、数组过大都是编译期

    ### 数组越界是运行期

    ### 访问修饰符是编译期的限制，多态是运行期多态，所以限制不住，能调用

    # 08宏和内联函数

    ## 宏

    ```c++
    #pragma once

    //宏替换，发生在预处理期
    #define AA 10

    /* \：反斜杠，链接当前行和下一行，最后一行一般不加，反斜杠后面什么也不加
    * 
    */
    #define BB for (int i = 0; i < AA; i++)\
    	{\
    	cout << i << endl;\
    	}
    extern int a;


    //带参数的宏
    #define CC(COUNT)\
    	for (int i = 0; i < COUNT; i++)\
    	{\
    	cout << i << " ";\
    	}

    #define DD(A,B) A*B

    #define EE(A,B) (A)*(B)

    #define FF(A,B) ((A)*(B))


    // #A  将转换为字符串，相当于在外面加 双引号
    #define HH(A) #A    

    //将参数转换为字符，相当于加 单引号
    #define JJ(A)  #@A

    //链接作用
    #define KK() int a##b=10;
    //可以用来定义 多个相似的类
    ```
    ### 特点

    宏替换，**发生在预处理期**

    宏定义时需要跨行时：**\：反斜杠**，链接当前行和下一行，最后一行一般不加，反斜杠后面什么也不加

    宏可以带参数

    但是宏的参数不会进行运算求解，例如

    `a = DD(2 + 3, 4);`宏只是单纯的替换  会替换成 2+3*4

    **所以需要在宏中加()，控制优先级**

    ### 功能

    1. #A  将转换为字符串，相当于在外面加 双引号
       #define HH(A) #A
    2. 将参数转换为字符，相当于加 单引号
       #define JJ(A)  #@A
    3. 链接作用，可以用来定义 多个相似的类  
       #define KK() int a##b=10
    4. #undef AA      AA宏的作用范围到此为止

    # 09运算符重载

    ```c++
    #include<iostream>
    using namespace std;

    /*
    重载操作符：本质上是一个比较特殊的函数，函数名operator后接要重载的操作符，
    参数要根据操作符的使用规则来，与使用时的类型、顺序、数量要保持一致。
    一般要有返回类型，为了和后续的操作符继续去操作。
    告诉编译器当遇到这个操作符时，应当调用该函数来实现一个操作符的功能，是对原来的操作的功能的扩展

    */

    /*

    类内：作为类成员函数，有隐藏的this指针作为做第一个参数，省略了一个参数，类对象应当匹配this。
    类外：类外：作为全局的重载操作符函数，没有隐藏的ths指针参数，会比类内的重载操作符函数多一个参数，且参数的顺序不是固定的，可以进行调整，
    注意是否与类内的重载操作符函数产生歧义。
    */
    class CTest
    {
    public:
    	int m_a;
    	CTest()
    	{
    		m_a = 10;
    	}

    	//operator  重载 操作符的关键字
    	//重载函数：返回类型 operator 后接要重载的操作符
    	int operator+(/*CTest * const this */int a)
    	{
    		return this->m_a + a;
    	}
    	int operator+=(/*CTest * const this */int a)
    	{
    		return this->m_a += a;
    	}

    	int operator=(int a)
    	{
    		this->m_a = a;
    		return m_a;
    	}
    };


    int main()
    {
    	CTest c1;
    	int a = c1 + 20;
    	cout << a<<endl;

    	int b=0;

    	c1 += 100;
    	cout << c1.m_a << endl;

    	cout << b << endl;

    	CTest c2;
    	c2 = c1 + 200;
    	cout << c2.m_a << endl;;

    	c2.operator+=(12);
    	cout << c2.m_a << endl;//当成函数使用，不推荐

    	return 0;
    }

    ```
    ## 重载操作符

    operator  重载 操作符的关键字

    本质上是一个比较特殊的函数，函数名 operator后接要重载的操作符，

    参数要根据操作符的使用规则来，与使用时的类型、顺序、数量要保持一致。一般要有返回类型，为了和后续的操作符继续去操作。
    告诉编译器当遇到这个操作符时，应当调用该函数来实现一个操作符的功能，是对原来的操作的功能的扩展

    重载函数：`返回类型 operator 后接要重载的操作符`

    类内：作为类成员函数，有隐藏的this指针作为做第一个参数，省略了一个参数，类对象应当匹配this。  
    类外：作为全局的重载操作符函数，没有隐藏的ths指针参数，会比类内的重载操作符函数多一个参数，且参数的顺序不是固定的，可以进行调整，  
    注意是否与类内的重载操作符函数产生歧义。

    ## 注意

    ### 使用限制

    1. 重载操作符函数不能改变操作符的使用规则，原来几个操作数，重载之后还是几个
    2. 重载操作符函数不能有默认值
    3. 重载操作符不能改变操作符的优先级和结合性
    4. =   []   ()   ->   操作符只能在类内重载

        这个不允许在类外重载  
        `int operator=(int a, CTest& tst)
        {
        }`​
    5. sizeof  ?:   .  .*     ::   不能重载
    6. 对应同一个重载操作符函数参数不同，可能就代表不同的函数，例如  *可能是乘法、间接引用，
    7. 必须制定一个结构体、类等自定义的类型
    8. 不允许对运算符重定义原本就有的功能，<u>运算符重载是增加功能而不是重写原来的功能</u>

    ### 情况应对

    1. 重载左++和右++的时候，右++需要加一个参数int。这个参数只是用来区分
    2. 与类内的产生歧义，解决方法1、注释掉一个；2、加作用域运算符

    ## 类型转换函数

    类型转换函数的作用/使用

    ```cpp
    #include<iostream>
    using namespace std;

    /*
    重载操作符和类型转换函数同时存在时，重载操作符优先级高
    */

    class CTest
    {
    public:
    	int m_a;
    	CTest()
    	{
    		m_a = 10;
    	}
    	//类型转换函数，函数名  operator  后加类型 ，无参数，无返回类型
    	operator int()
    	{
    		return m_a;//但是必须写一个返回
    	}
    	int operator+(int a)//优先级高
    	{
    		return this->m_a + a;
    	}

    };

    int main()
    {


    	int a = 0;
    	CTest tst;
    	a = *(int*)&tst;
    	cout << a << endl;//10

    	tst.m_a = 20;
    	a = tst;
    	cout << a << endl;//20

    }
    ```
    ![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662206882158.png)​

    重载操作符和类型转换函数同时存在时，重载操作符优先级高

    ## 运算符重载的应用——对链表的重构

    ```cpp
    #include<iostream>
    using namespace std;



    struct Node {
    public:
    	int val;
    	Node* pNext;
    	Node(int v) {   //构造函数
    		val = v;
    		pNext = nullptr;
    	}
    };


    class CMyIterator {
    public:
    	Node* m_pTemp;
    	CMyIterator(Node* pNode) :m_pTemp(pNode) {
    		//m_pTemp = pNode;
    	}
    	Node* operator=(Node* pNode) {
    		m_pTemp = pNode;
    		return m_pTemp;
    	}
    	bool operator==(Node* pNode) {
    		return m_pTemp == pNode;
    	}
    	bool operator!=(Node* pNode) {
    		return m_pTemp != pNode;
    	}
    	int operator*() {
    		return m_pTemp ? m_pTemp->val : -1;
    	}
    	Node* operator++() {
    		m_pTemp = m_pTemp->pNext;
    		return m_pTemp;
    	}
    	Node* operator++(int) {
    		Node* p = m_pTemp;  //标记加之前的
    		m_pTemp = m_pTemp->pNext;
    		return p;
    	}
    	operator bool() {
    		return m_pTemp;
    	}
    };

    class CMyList {
    public:
    	//void ShowList() {
    	//	Node* pTemp = m_pHead;  //标记头，初始化
    	//	pTemp = m_pHead;   //赋值  operator=
    	//	while (pTemp) {    //operator == operator!= operator bool
    	//		cout << pTemp->val << "   ";  //*pTemp    operator*
    	//		pTemp = pTemp->pNext;  //pTemp++   operator++
    	//	}
    	//	cout << endl;
    	//}
    	void ShowList() {
    		CMyIterator ite = m_pHead;   // Node* pTemp = m_pHead;  //标记头，初始化
    		ite = m_pHead;               //pTemp = m_pHead;   //赋值  operator=
    		while (ite) {//while (ite != nullptr){      //while (pTemp) {    //operator == operator!= operator bool
    			cout << *ite << "    ";  //cout << pTemp->val << "   ";  //*pTemp    operator*
    			ite++;                   //pTemp = pTemp->pNext;  //pTemp++   operator++
    		}
    		cout << endl;
    	}

    public:
    	Node* m_pHead; //头尾指针
    	Node* m_pEnd;
    	int   m_nLen;   //链表长度
    public:
    	CMyList() {
    		m_pHead = nullptr;
    		m_pEnd = nullptr;
    		m_nLen = 0;
    	}
    	~CMyList() {
    		Node* pTemp = nullptr;
    		while (m_pHead) {
    			pTemp = m_pHead;   //标记当前头结点

    			m_pHead = m_pHead->pNext;
    			delete pTemp;
    		}
    		m_pHead = nullptr;
    		m_pEnd = nullptr;
    		m_nLen = 0;
    	}
    public:
    	void PushBack(int v) {
    		//创建一个结点
    		Node* pNode = new Node(v);   //匹配带参数的构造函数

    		if (m_pHead) {   //非空链表
    			m_pEnd->pNext = pNode;
    			//m_pEnd = m_pEnd->pNext;
    			//m_pEnd = pNode;
    		}
    		else {  //空链表
    			m_pHead = pNode;
    		}
    		m_pEnd = pNode;
    		++m_nLen;   //长度增加
    	}

    	void PopFront() {
    		if (m_pHead) {  //非空链表

    			Node* pTemp = m_pHead;  //先标记头
    			if (m_pHead == m_pEnd) {  //只有一个结点
    				m_pHead = nullptr;
    				m_pEnd = nullptr;
    			}
    			else {
    				m_pHead = m_pHead->pNext;   //头结点向后移动
    			}

    			delete pTemp;   //删除标记的节点
    			pTemp = nullptr;

    			--m_nLen;   //长度减少
    		}
    	}

    	int GetLen() {
    		return m_nLen;
    	}
    };




    int main() {

    	CMyList myList;
    	myList.PushBack(1);
    	myList.PushBack(2);
    	myList.PushBack(3);
    	myList.PushBack(4);
    	cout << "len = " << myList.GetLen() << endl;
    	myList.ShowList();   //遍历


    	myList.PopFront();
    	myList.PopFront();
    	cout << "len = " << myList.GetLen() << endl;
    	myList.ShowList();   //遍历




    	return 0;
    }
    ```
    # 10构造函数中的细节

    ## 拷贝构造函数

    拷贝构造函数operator=-科林[^12]

    ### 定义

    拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用。

    ```c++
    class 类名 
    { public : 类名（形参）；//构造函数
                    类名（类名 &对象名）；//拷贝构造函数 ... 
    }；
        
    //拷贝构造函数 ... 
    类名::类（类名 &对象名）//拷贝构造函数的实现
    { 函数体 }
    如：
    Box∷Box(const Box& b)
    {
    	height=b.height;
    	width=b.width;
    	length=b.length;
    }
    ```
    复制构造函数也是**构造函数**，但它只有一个参数，这个参数是本类 的对象(不能是其他类的对象)，而且采用对象的**引用的形式**(一般约定 加const声明，使参数值不能改变，以免在调用此函数时因不慎而使对 象值被修改)。

    如果用户自己未定义复制构造函数，则编译系统会自动提供一个默认的 复制构造函数，其作用只是简单地复制类中每个数据成员。（效果上是浅拷贝）

    ### 注意普通构造函数和复制构造函数的区别

    1. 在形式上

    ```c++
    类名(形参表列); //普通构造函数的声明，如Box(int h,int ,int en);

    类名(类名& 对象名); //复制构造函数的声明，如Box(Box &b);
    ```
    2. 在建立对象时，实参类型不同

    系统会根据实参的类型决定调用普通构造函数或复制构造函数。

    ```c++
    Box box1(12,15,16); //实参为整数，调用普通构造函数

    Box box2(box1); //实参是对象名，调用复制构造函数
    ```
    3. 调用时候不同

    **普通构造函数**在程序中**建立对象时**被调用。

    **复制构造函数**在用**已有对象复制一个新对象**时被调用

    ### 调用

    普通构造函数在程序中建立对象时被调用。 复制构造函数在用已有对象复制一个新对象时被调用，在以下3 种情况下需要克隆对象：

    1. 程序中需要新建立一个对象，并用另一个同类的对象对它初始化：

    box2=box1//box2(box1)

    2. 当函数的参数为类的对象时。在调用函数时需要将实参对象 完整地传递给形参，也就是需要建立一个实参的拷贝，这 就是按实参复制一个形参，系统是通过调用复制构造函数 来实现的，这样能保证形参具有和实参完全相同的值。==简言之：函数传值的形式传对象时，系统自动调用类的拷贝构造含函数 ​==

        如

    ```C++
    void fun(Box b) //形参是类的对象

    {  }

    int main( )

    {Box box1(12,15,18);

    fun(box1); //实参是类的对象，调用函数时将复制一个新对象b

    return 0;

    }
    ```
    3. 函数的返回值是类的对象。 在函数调用完毕将返回值带回函数调用处时。此时需要将函数中的对象 复制一个临时对象并传给该函数的调用处。如：

    ```c++
    Box f( ) //函数f的类型为Box类类型

    { Box box1(12,15,18);

    return box1; //返回值是Box类的对象

    }

    int main( ){

    Box box2; //定义Box类的对象box2

    box2=f( ); //调用f函数，返回Box类的临时对象，并将它赋值给box2

    }
    ```
    以上几种调用复制构造函数都是由编译系统自动实现的，不必由用户自 己去调用，只要知道在这些情况下需要调用复制构造函数就可以了。

    ‍

    #### 调用拷贝构造函数的例子（Point类为例）

    ```C++
    #include "iostream"
    using namespace std;

    //定义一个Point类
    class Point{
    public:
    	Point(int xx=0,int yy=0):x(xx),y(yy){}     //构造函数
    	~Point(){ };                              //析构函数
        Point(const Point &p);                //复制构造函数
    	int getX()const{return x;}
    	int getY()const {return y;}
    private:
    	int x,y;//私有成员

    };

    Point::Point(const Point &p)
    {
    	x = p.x;
    	y = p.y;
    	cout << "Calling the copy constructor" <<endl;

    }
    //形参作为Point类对象的函数
    void fun1(Point p)
    {
    	cout<< p.getX()<<endl;

    }

    //返回类的对象
    Point fun2()
    {
    	Point a(1,2);
    	return a;
    }

    int main()
    {
    	Point a(4);    //第一个对象A,该过程利用了重载，后面的y默认为0
    	
    Point b(a);      //此时调用copy构造函数；情况1，用a初始化b，第一次调用copy构造函数
    cout << b.getX()<<endl; 

    fun1(b);  //此时调用copy构造函数；类的对象在函数中为实参，第二次调用copy构造函数

    b = fun2();//此时调用copy构造函数；函数返回值为类的对象，第三次调用copy构造函数
    cout << b.getX()<<endl; 
    return 0;

    }
    ```
    ## 转换构造函数

    ### 定义

    支持发生隐式类型转换的构造函数

    ### 特征

    这种构造函数的特征，至少需要传入一个值进行赋值，一个以上则不行

    ### 功能

    ```sql
    CTest tst4 = 100;
    cout << tst4.m_a << endl;
    ```
    ### 禁止发生隐式类型转换

    **explcit 关键字**

    修饰构造函数，禁止发生隐式类型转换

    ## 在是声明一个类时，编译器会为我们提供的

    空类中会有哪些默认的函数：

    1. 默认的无参构造
    2. 默认的析构函数
    3. 默认的拷贝构造函数[^13]
    4. 默认的operator=[^14]函数

    ‍

    ## 拷贝构造函数：

    也是编译器默认给提供的一种构造函数，  函数原型 CTest(const CTest& )， 重点是& 引用，一定要加上，不加会有问题函数体代码为不空，形参中的对象成员给this对象成员依次初始化一旦我们手动重构了拷贝构造，编译器就不会提供了默认的拷贝构造了当用当前的类对象给另一个类对象去初始化时，会调用拷贝构造默认的拷贝构造函数他是一个**浅拷贝**，可能会有浅拷贝的问题

    ### 浅拷贝问题：

    1.  两个指针指向了同一块内存，当其中一个对象回收这个内存后，另一个对象在回收内存就会出问题
    2.  当通过其中一个对象修改了内存空间的值，另一个对象再使用就是修改之后的值了

    ### 解决浅拷贝：

    **深拷贝**,手动重构构造函数，并且为拷贝的指针额外申请属于自己的空间  
    函数参数为结构体、类类型，应当使用引用或指针，来避免浅拷贝的发生

    ```cpp
    #include<iostream>
    using namespace std;

    class CTest {
    public:
    	int m_a;
    	int* m_p;
    	CTest() {
    		m_a = 10;
    		m_p = new int(20);  //申请额外的空间
    	}
    	//拷贝构造函数：也是编译器默认给提供的一种构造函数，  函数原型 CTest(const CTest& )， 重点是& 引用，一定要加上，不加会有问题
    	//函数体代码为不空，形参中的对象成员给this对象成员依次初始化
    	//一旦我们手动重构了拷贝构造，编译器就不会提供了默认的拷贝构造了
    	// 当用当前的类对象给另一个类对象去初始化时，会调用拷贝构造
    	// 默认的拷贝构造函数他是一个浅拷贝，可能会有浅拷贝的问题
    	//浅拷贝问题：
    	// 1. 两个指针指向了同一块内存，当其中一个对象回收这个内存后，另一个对象在回收内存就会出问题
    	// 2. 当通过其中一个对象修改了内存空间的值，另一个对象再使用就是修改之后的值了
    	//CTest(const CTest& tst):m_a(tst.m_a),m_p(tst.m_p) {
    	//	cout << "CTest(const CTest& tst)" << endl;
    	//}
    	//解决浅拷贝的 问题，深拷贝,手动重构构造函数，并且为拷贝的指针额外申请属于自己的空间
    	// 函数参数为结构体、类类型，应当使用引用或指针，来避免浅拷贝的发生
    	CTest(const CTest& tst) :m_a(tst.m_a)/*, m_p(tst.m_p)*/ {
    		cout << "CTest(const CTest& tst)" << endl;
    		if (tst.m_p) {
    			this->m_p = new int(*tst.m_p);  //new 空间
    		}
    		else {
    			this->m_p = nullptr;
    		}
    	}
    	//空类中也会提供一个 默认的operator=,  函数体代码不为空，形参中的对象成员给this对象成员依次赋值
    	//一旦我们手动重构了operator=，编译器就不会提供了默认的operator=了
    	//默认的  operator=  也是一个浅拷贝，也会有浅拷贝的问题。
    	//解决：深拷贝
    	/*CTest& operator=(const CTest& tst) {
    		this->m_a = tst.m_a;
    		this->m_p = tst.m_p;
    		return *this;
    	}*/
    	//深拷贝
    	CTest& operator=(const CTest& tst) {
    		if (this != &tst) {  //判断是否是自己
    			this->m_a = tst.m_a;
    			//this->m_p = tst.m_p;
    			if (tst.m_p) {
    				if (this->m_p) {
    					*this->m_p = *tst.m_p;
    				}
    				else {
    					this->m_p = new int(*tst.m_p);
    				}
    			} 
    			else {
    				if (this->m_p) {
    					delete this->m_p;
    				}
    				this->m_p = nullptr;
    			}
    		}

    		return *this;
    	}

    	~CTest() {
    		if (m_p) {  //回收额外的空间
    			delete m_p;
    			m_p = nullptr;
    		}
    	}
    };


    void fun(CTest& tst) {    //尽量使用指针或者引用
    	cout << *tst.m_p << endl;
    }


    int main() {
    	//CTest tst;

    	//CTest tst2(tst);   //手动重构之后，调用的就是自己写的拷贝构造函数了
    	//cout << tst2.m_a << endl;  //10

    	//-------------------------------------
    	//CTest tst3;

    	//CTest tst4(tst3);
    	//cout << tst4.m_a << "    " << *tst4.m_p << endl;

    	//*tst3.m_p = 100;

    	//cout << *tst4.m_p << endl;

    	//CTest tst5;
    	//fun(tst5);

    	//----------------------------------------------
    	CTest tst6;
    	CTest tst7;
    	tst6.m_a = 20;
    	tst7 = tst6;  //赋值
    	cout << tst7.m_a << endl;

    	tst7 = tst7;  //自己给自己赋值，
    	//---------------------------------
    	cout << *tst6.m_p << endl;
    	*tst7.m_p = 100;
    	cout << *tst6.m_p << endl;


    	return 0;
    }

    /*
    空类中会有哪些默认的函数：
    默认的无参构造
    默认的析构函数
    默认的拷贝构造函数
    默认的 operator= 函数

    */
    ```
    ### operator=

    空类中也会提供一个 默认的operator=,  函数体代码不为空，形参中的对象成员给this对象成员依次赋值一旦我们手动重构了operator=，编译器就不会提供了默认的operator=了默认的  operator=  也是一个浅拷贝，也会有浅拷贝的问题。

    ### 解决：深拷贝

    ```cpp
    //空类中也会提供一个 默认的operator=,  函数体代码不为空，形参中的对象成员给this对象成员依次赋值
    	//一旦我们手动重构了operator=，编译器就不会提供了默认的operator=了
    	//默认的  operator=  也是一个浅拷贝，也会有浅拷贝的问题。
    	//解决：深拷贝
    	/*CTest& operator=(const CTest& tst) {
    		this->m_a = tst.m_a;
    		this->m_p = tst.m_p;
    		return *this;
    	}*/
    	//深拷贝
    	CTest& operator=(const CTest& tst) {
    		if (this != &tst) {  //判断是否是自己
    			this->m_a = tst.m_a;
    			//this->m_p = tst.m_p;
    			if (tst.m_p) {
    				if (this->m_p) {
    					*this->m_p = *tst.m_p;
    				}
    				else {
    					this->m_p = new int(*tst.m_p);
    				}
    			} 
    			else {
    				if (this->m_p) {
    					delete this->m_p;
    				}
    				this->m_p = nullptr;
    			}
    		}

    		return *this;

    ```
    ‍


[^10]: ### 9.5 const修饰指针

    const修饰指针有三种情况

    1. const修饰指针   --- 常量指针
    2. const修饰常量   --- 指针常量
    3. const即修饰指针，又修饰常量

    **示例：**

    ```c++
    int main() {

      int a = 10;
      int b = 10;

      //const修饰的是指针，指针指向可以改，指针指向的值不可以更改
      const int * p1 = &a; 
      p1 = &b; //正确
      //*p1 = 100;  报错

      //const修饰的是常量，指针指向不可以改，指针指向的值可以更改
      int * const p2 = &a;
      //p2 = &b; //错误
      *p2 = 100; //正确

        //const既修饰指针又修饰常量
      const int * const p3 = &a;
      //p3 = &b; //错误
      //*p3 = 100; //错误

      system("pause");

      return 0;
    }
    ```
    > 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量
    >

    * *const int * p叫常量指针，*p的操作不可** （p- >也不可）

    **int * const p叫指针常量，p的操作不可**


[^11]: #### 命名空间

    ```c++
    #include<iostream>
    using namespace std;

    namespace AA//namespace 定义命名空间的关键字，主要作用：区分同一个作用域下的同名成员
    {
    	int a = 20;
    	//int* p = &a;
    };
    namespace BB
    {
    	int a = 30;
    };
    /*将原本同在全局区的a=20和a=30分别放入AA和BB命名空间中，实现了作用域的划分*/

    int main()
    {
    	int a = 10;

    	cout << a << endl;

    	//cout << *p << endl;

    	//:: ：作用域运算符，符号前面指明哪个作用域，符号后面指明作用域中的成员，
    	//		::符号前未指明时，默认代表是全局
    	//cout << ::a << endl;

    	cout << AA::a << endl;
    	cout << BB::a << endl;
    }

    ```
    ​

    ##### 命名空间知识点总结

    1. namespace 		 定义命名空间的关键字  
        主要作用：区分同一个作用域下的同名成员
    2. ::                          作用域运算符  
        符号前面指明哪个作用域，符号后面指明作用域中的成员，::符号前未指明时，默认代表是全局
    3. 使用命名空间的方法

        1. 显式的指定，

            ```cpp
            命名空间 :: 成员  
            ```
        2. 打开某一个命名空间

            ```cpp
            using namespace 已有的命名空间 ;
            ```

    				打开命名空间，命名空间中的就对外开放了

    ‍


[^13]: ## 拷贝构造函数

    拷贝构造函数operator=-科林[^12]

    ### 定义

    拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用。

    ```c++
    class 类名 
    { public : 类名（形参）；//构造函数
                    类名（类名 &对象名）；//拷贝构造函数 ... 
    }；
        
    //拷贝构造函数 ... 
    类名::类（类名 &对象名）//拷贝构造函数的实现
    { 函数体 }
    如：
    Box∷Box(const Box& b)
    {
    	height=b.height;
    	width=b.width;
    	length=b.length;
    }
    ```
    复制构造函数也是**构造函数**，但它只有一个参数，这个参数是本类 的对象(不能是其他类的对象)，而且采用对象的**引用的形式**(一般约定 加const声明，使参数值不能改变，以免在调用此函数时因不慎而使对 象值被修改)。

    如果用户自己未定义复制构造函数，则编译系统会自动提供一个默认的 复制构造函数，其作用只是简单地复制类中每个数据成员。（效果上是浅拷贝）

    ### 注意普通构造函数和复制构造函数的区别

    1. 在形式上

    ```c++
    类名(形参表列); //普通构造函数的声明，如Box(int h,int ,int en);

    类名(类名& 对象名); //复制构造函数的声明，如Box(Box &b);
    ```
    2. 在建立对象时，实参类型不同

    系统会根据实参的类型决定调用普通构造函数或复制构造函数。

    ```c++
    Box box1(12,15,16); //实参为整数，调用普通构造函数

    Box box2(box1); //实参是对象名，调用复制构造函数
    ```
    3. 调用时候不同

    **普通构造函数**在程序中**建立对象时**被调用。

    **复制构造函数**在用**已有对象复制一个新对象**时被调用

    ### 调用

    普通构造函数在程序中建立对象时被调用。 复制构造函数在用已有对象复制一个新对象时被调用，在以下3 种情况下需要克隆对象：

    1. 程序中需要新建立一个对象，并用另一个同类的对象对它初始化：

    box2=box1//box2(box1)

    2. 当函数的参数为类的对象时。在调用函数时需要将实参对象 完整地传递给形参，也就是需要建立一个实参的拷贝，这 就是按实参复制一个形参，系统是通过调用复制构造函数 来实现的，这样能保证形参具有和实参完全相同的值。==简言之：函数传值的形式传对象时，系统自动调用类的拷贝构造含函数 ​==

        如

    ```C++
    void fun(Box b) //形参是类的对象

    {  }

    int main( )

    {Box box1(12,15,18);

    fun(box1); //实参是类的对象，调用函数时将复制一个新对象b

    return 0;

    }
    ```
    3. 函数的返回值是类的对象。 在函数调用完毕将返回值带回函数调用处时。此时需要将函数中的对象 复制一个临时对象并传给该函数的调用处。如：

    ```c++
    Box f( ) //函数f的类型为Box类类型

    { Box box1(12,15,18);

    return box1; //返回值是Box类的对象

    }

    int main( ){

    Box box2; //定义Box类的对象box2

    box2=f( ); //调用f函数，返回Box类的临时对象，并将它赋值给box2

    }
    ```
    以上几种调用复制构造函数都是由编译系统自动实现的，不必由用户自 己去调用，只要知道在这些情况下需要调用复制构造函数就可以了。

    ‍

    #### 调用拷贝构造函数的例子（Point类为例）

    ```C++
    #include "iostream"
    using namespace std;

    //定义一个Point类
    class Point{
    public:
    	Point(int xx=0,int yy=0):x(xx),y(yy){}     //构造函数
    	~Point(){ };                              //析构函数
        Point(const Point &p);                //复制构造函数
    	int getX()const{return x;}
    	int getY()const {return y;}
    private:
    	int x,y;//私有成员

    };

    Point::Point(const Point &p)
    {
    	x = p.x;
    	y = p.y;
    	cout << "Calling the copy constructor" <<endl;

    }
    //形参作为Point类对象的函数
    void fun1(Point p)
    {
    	cout<< p.getX()<<endl;

    }

    //返回类的对象
    Point fun2()
    {
    	Point a(1,2);
    	return a;
    }

    int main()
    {
    	Point a(4);    //第一个对象A,该过程利用了重载，后面的y默认为0
    	
    Point b(a);      //此时调用copy构造函数；情况1，用a初始化b，第一次调用copy构造函数
    cout << b.getX()<<endl; 

    fun1(b);  //此时调用copy构造函数；类的对象在函数中为实参，第二次调用copy构造函数

    b = fun2();//此时调用copy构造函数；函数返回值为类的对象，第三次调用copy构造函数
    cout << b.getX()<<endl; 
    return 0;

    }
    ```
