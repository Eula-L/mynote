# 00面向对象设计

  

## 概念

  

　　面向对象程序设计（Object-Oriented Programming，OOP）是一种新的程序设计范型。程序设计范型是指设计程序的规范、模型和风格，它是一类程序设计语言的基础。

  

　　面向过程程序设计范型是使用较广泛的面向过程性语言，其主要特征是：程序由过程定义和过程调用组成（简单地说，过程就是程序执行某项操作的一段代码，函数就是最常用的过程）。

  

　　面向对象程序的基本元素是对象，面向对象程序的主要结构特点是：第一，程序一般由类的定义和类的使用两部分组成；第二，程序中的一切操作都是通过向对象发送消息来实现的，对象接收到消息后，启动有关方法完成相应的操作。  

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108869979.png)​

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108808933.png)​

  

　　**对象**：描述其属性的数据以及对这些数据施加的一组操作封装在一起构成的统一体。对象可认为是数据+操作。

  

　　**类**：类是具有相同的数据和相同的操作的一组对象的集合。

  

　　消息传递：对象之间的交互。

  

　　**方法：**对象实现的行为称为方法。

  

　　面向对象程序设计的基本特征：抽象、封装、继承、多态。  

  

# 01C++基础

  

#### 命名空间

  

```c++

#include<iostream>

using namespace std;

  

namespace AA//namespace 定义命名空间的关键字，主要作用：区分同一个作用域下的同名成员

{

    int a = 20;

    //int* p = &a;

};

namespace BB

{

    int a = 30;

};

/*将原本同在全局区的a=20和a=30分别放入AA和BB命名空间中，实现了作用域的划分*/

  

int main()

{

    int a = 10;

  

    cout << a << endl;

  

    //cout << *p << endl;

  

    //:: ：作用域运算符，符号前面指明哪个作用域，符号后面指明作用域中的成员，

    //      ::符号前未指明时，默认代表是全局

    //cout << ::a << endl;

  

    cout << AA::a << endl;

    cout << BB::a << endl;

}

  

```

  

　　​

  

##### 命名空间知识点总结

  

1. namespace         定义命名空间的关键字  

    主要作用：区分同一个作用域下的同名成员

2. ::                          作用域运算符  

    符号前面指明哪个作用域，符号后面指明作用域中的成员，::符号前未指明时，默认代表是全局

3. 使用命名空间的方法

  

    1. 显式的指定，

  

        ```cpp

        命名空间 :: 成员  

        ```

    2. 打开某一个命名空间

  

        ```cpp

        using namespace 已有的命名空间 ;

        ```

  

　　              打开命名空间，命名空间中的就对外开放了

  

　　‍

  

#### const修饰常量

  

　　9.5 const修饰指针[^1]

  

　　在C语言中，习惯使用#define来定义常量，例如#​​define PI 3.14，C++提供了一种更灵活、更安全的方式来定义常量，即使用const修饰符来定义常量。例如const float PI = 3.14；

  

　　const可以与指针一起使用，它们的组合情况复杂，可归纳为3种：指向常量的指针、常指针和指向常量的常指针。  

  

　　**指向常量的指针**：一个指向常量的指针变量。

  

```cpp

const char* pc = "abcd";

该方法不允许改变指针所指的变量，即

    pc[3] = ‘x';   是错误的，

但是，由于pc是一个指向常量的普通指针变量，不是常指针，因此可以改变pc所指的地址，例如

    pc = "ervfs";

该语句付给了指针另一个字符串的地址，改变了pc的值。

  

```

  

　　**常指针**：将指针变量所指的地址声明为常量

  

```cpp

char* const pc = "abcd";

创建一个常指针，一个不能移动的固定指针，可更改内容，如

    pc[3] = 'x';

但不能改变地址，如

    pc = 'dsff';  不合法

  

```

  

　　**指向常量的常指针**：这个指针所指的地址不能改变，它所指向的地址中的内容也不能改变。

  

```cpp

const char* const pc = "abcd";

内容和地址均不能改变

  

```

  

> 说明：

>

> 如果用const定义整型常量，关键字可以省略。即 const in bufsize = 100 与 const bufsize = 100等价；

>

> 常量一旦被建立，在程序的任何地方都不能再更改。

>

> 与#define不同，const定义的常量可以有自己的数据类型。

>

> 函数参数也可以用const说明，用于保证实参在该函数内不被改动。

  

　　‍

  

#### void指针

  

　　void通常表示无值，但将void作为指针的类型时，它却表示不确定的类型。这种void型指针是一种通用型指针，也就是说任何类型的指针值都可以赋给void类型的指针变量。

  

　　需要指出的是，这里说void型指针是通用指针，是指它可以接受任何类型的指针的赋值，但对已获值的void型指针，对它进行再处理，如输出或者传递指针值时，则必须再进行显式类型转换，否则会出错  

  

```cpp

    void* pc;

    int i = 123;

    char c = 'a';

    pc = &i;

    cout << pc << endl;         //输出指针地址006FF730

    cout << *(int*)pc << endl;  //输出值123

    pc = &c;

    cout << *(char*)pc << endl; //输出值a

  

```

  

#### 内联函数(inline)

  

　　在函数名前冠以关键字`inline`​​​，该函数就被声明为**内联函数**。每当程序中出现对该函数的调用时，C++编译器使用函数体中的代码插入到调用该函数的语句之处，同时使用实参代替形参，以便在程序运行时不再进行函数调用。引入[内联函数](https://so.csdn.net/so/search?q=%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)主要是为了消除调用函数时的系统开销，以提高运行速度。

  

1. inline ：定义内联函数的关键字，编译阶段进行替换，提高函数的运行效率

2. 内联函数在第一次被调用之前必须进行完整的定义，否则编译器将无法知道应该插入什么代码

3. 本质是代码的替换  

    相对于函数，调用次数比较多的时候，占用内存，空间换时间  

    使用内联函数是一种空间换时间的措施，若内联函数较长，较复杂且调用较为频繁时不建议使用

4. 适用场景：代码量少，逻辑比较简单，存在while，for，do while不推荐作为内联函数

5. inline是建议性关键字  

    递归函数、虚函数即使加了inline，也不会是内联函数

6. **使用内联函数替代宏定义，能消除宏定义的不安全性**

  

```cpp

#include<iostream>

using namespace std;

int add(int a, int b)

{

    return a + b;

}

  

#define ADD(A,B)  ((A)+(B))

  

inline int Add(int a, int b)

{

    return a + b;

}

  
  

int main()

{

    int a = add(10, 20);

    cout << a << endl;

  

    a = ADD(100, 200);

    cout << a << endl;

  

    a = Add(1, 2);

    cout << a << endl;

  

    return 0;

}

```

  

#### 带有默认参数值的函数

  

　　函数指定默认值（默认形参值）

  

　　当进行函数调用时，编译器按从左到右的顺序将实参与形参结合，若未指定足够的实参，则编译器按顺序用函数原型中的默认值来补足所缺少的实参。

  

```C++

#include<iostream>

using namespace std;

  

//有传入值，用传入的，没有用默认

void fun3(int a, int b, int c = 30)

{

    cout << a << endl;

    cout << b << endl;

    cout << c << endl;

}

  

/*

中间位置的变量定义默认值，会报错

void fun3(int a, int b=30, int c )

{

    cout << a << endl;

    cout << b << endl;

    cout << c << endl;

}

  

*/

void fun4(int a, int b=20, int c = 100);//指定参数默认值，一般在函数声明时指定（而不是在定义时）

  
  

int main()

{

    fun3(100, 200, 300);

    fun4(10,30);

    return 0;

}

  

void fun4(int a, int b, int c)

{

    cout << a << endl;

    cout << b << endl;

    cout << c << endl;

}

```

  

##### 结论

  

1. 当函数的声明和定义分开写时，**指定参数默认值，一般在函数声明时指定**（而不是在定义时）

2. **传值**的规则是，**从左到右依次传值，中间不可以有间断**。

  

    **指定默认值**的规则是，**从右往左依次指定，中间不可以中断**，所以只有中间位置的变量指定默认值，会报错。

3. 调用函数时，有传入值，用传入的，没有用默认

  

　　‍

  

#### 函数重载

  

　　在C++中，用户可以重载函数。这意味着，在同一[作用域](https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020)内，只要函数参数的类型不同，或者参数的个数不同，或者二者兼而有之，两个或者两个以上的函数可以使用相同的函数名。

  

　　函数的重载使得C++程序员对完成类以功能的不同函数可以统一命名，减少了命名所花的心思。在调用函数时，编译器会根据实参的类型、数量自动匹配对应类型函数。

  

```cpp

#include<iostream>

using namespace std;

int add(int a, int b)

{

    return a + b;

}

int add(int a, int b,int c)

{

    return a + b + c;

}

double add(double a, double b)

{

    return a + b;

}

void fun(int a, char b)

{}

void fun(char b,int a)

{}

  
  

int main()

{

    int a = 10, b = 20;

    double aa = 12.3, bb = 34.56;

    cout << add(a, b) << endl;

    cout << add(aa, bb) << endl;

  

    return 0;

}

```

  

##### 注意

  

1. 函数重载：描述了多个函数的关系，

  

    1. 函数名相同，

    2. **参数列表（参数类型、数量、顺序）不同**，

    3. 对返回类型没有要求（可以相同，也可以不同，不在参数匹配考察之列）

2. 函数的重载与带默认值的函数一起使用时，有可能引起二义性。

  

    ```cpp

    void Drawcircle(int r = 0, int x = 0, int y = 0);

    void Drawcircle(int r);

    Drawcircle(20);

    ```

3. 在调用函数时，如果给出的实参和形参类型不相符，C++的编译器会自动地做类型转换工作。如果转换成功，则程序继续执行，在这种情况下，有可能产生不可识别的错误。

  

    ```cpp

    void f_a(int x);

    void f_a(long x);

    f_a(20.83);

  

    ```

4. 是重定义，不是函数重载

  

    ```c++

    void fun1(int*)

    {}

    void fun1(int p[])

    {}

    ```

  

　　‍

  

###### 作用域标识符"::"

  

　　命名空间[^2]

  

　　通常情况下，如果有两个同名变量，一个是全局的，另一个是局部的，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。

  

　　如果希望在局部变量的作用域内使用同名的全局变量，可以在该变量前加上“`::`​​”，此时`::value`​​代表全局变量value，“`::`​​”称为作用域标识符。

  

```cpp

#include <iostream>

using namespace std;

  

int value;   //定义全局变量value

  

int main()

{

    int value;  //定义局部变量value

    value = 100;

    ::value = 1000;

    cout << "local value : " << value << endl;

    cout << "global value : " << ::value << endl;

    return 0;

}

  

```

  

#### 强制类型转换

  

　　可用[强制类型转换](https://so.csdn.net/so/search?q=%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020)将不同类型的数据进行转换。例如，要把一个整型数（int）转换为双精度型数（double），可使用如下的格式：

  

```cpp

int i = 10;

double x = (double)i;

或

int i = 10;

double x = double(i);

  

```

  

　　以上两种方法C++都能接受，建议使用后一种方法。

  

#### new和delete运算符

  

　　程序运行时，计算机的内存被分为4个区：程序代码区、全局数据区、堆和栈。其中，堆可由用户分配和释放。C语言中使用函数`malloc()`​​和`free()`​​来进行动态内存管理。C++则提供了[运算符](https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1001.2101.3001.7020)​`new`​​和`delete`​​来做同样的工作，而且后者比前者性能更优越，使用更灵活方便。

  

```cpp

指针变量名 = new 类型

    int *p;

    p = new int;

delete 指针变量名

    delete p;

  

```

  

　　下面对new和delete的使用再做一下几点说明：

  

1. 用运算符new分配的空间，使用结束后应该用也只能用delete显式地释放，否则这部分空间将不能回收而变成死空间。

2. 在使用运算符new动态分配内存时，如果没有足够的内存满足分配要求，new将返回空指针（NULL）。

3. 使用运算符new可以为数组动态分配内存空间，这时需要在类型后面加上数组大小。

  

    ```cpp

    指针变量名 = new 类型名[下标表达式];

    int *p = new int[10];

  

    ```

  

    释放动态分配的数组存储区时，可使用delete运算符。

  

    ```cpp

    delete []指针变量名;

    delete p;

  

    ```

  

4. new 可在为简单变量分配空间的同时，进行初始化

  

    ```cpp

    指针变量名 = new 类型名(初值);

    int *p;

    p = new int(99);

    ···

    delete p;

  

    ```

  

##### 比较malloc--free和new-delete：

  

```c++

#include<iostream>

using namespace std;

int main()

{

    //c动态申请空间 动态：申请的空间大小可变

    int* p1 = (int*)malloc(sizeof(int));

    *p1 = 10; //赋值而不是初始化

    cout << *p1 << endl;

    free(p1);

    p1 = NULL;

  

    //----------------------

    //cpp动态申请空间 new 关键字，后面放要申请的类型（不需要计算大小），返回对应类型的地址

    int *p2=new int;

    *p2 = 20;

    cout << *p2 << endl;

    delete p2;

    p2 = NULL;

  

    int *p3=new int(30);

    cout << *p3 << endl;

    delete p3;

    p3 = NULL;

  

    //申请一个数组

    int *p4=new int[5];//new返回的数组是首元素的首地址

    for (int i = 0; i < 5; i++)

    {

        p4[i] = i * 10;

    }

    for (int i = 0; i < 5; i++)

    {

        cout << p4[i] << " ";

    }

    delete[]p4;//回收数组时候，指针前面加[]

    p4 = NULL;

    cout << endl;

  

    int* p5 = new int[5]();//申请空间并且 默认初始化

    for (int i = 0; i < 5; i++)

    {

        cout << p5[i] << " ";

    }

    delete[]p5;

    p5 = NULL;

    cout << endl;

  

    int* p6 = new int[5]{5,4,3,2,1};//申请空间并且 自定义初始化

    for (int i = 0; i < 5; i++)

    {

        cout << p6[i] << " ";

    }

    delete[]p6;

    p6 = NULL;

    cout << endl;

  

    return 0;

}

```

  

##### malloc--free和new-delete的区别：

  

1. malloc-free函数，需要头文件支持，new-delete关键字需要编译器的支持

2. malloc申请空间需要传申请空间的大小（需要计算），new需要的是类型，根据类型自动计算所需要的空间大小，ma1loc返回的是泛型指针(void*)一般需要强转为我们所需要的类型，new返回对应类型的地址不需要强转。

3. new申请空间可以指定初始化值，malloc不可以

4. **new申请结构体、类对象可以自动调用构造函数，delete可以自动调用析构函数**

  

##### new常见的使用：

  

```C++

struct AA

{

  

};

  

int main ()

{

    int **p1=new int*;//new 整型指针

    delete p1;

    p1 = NULL;

    int**p2=new int*[5];//new 整型指针数组

    delete p2;

    p2 = NULL;

  

    int **p1=new int*;//new 整型指针

    delete p1;

    p1 = NULL;

    int**p2=new int*[5];//new 整型指针数组

    delete p2;

    p2 = NULL;

  

    int(**p3)[5] = new (int(*)[5]);//new 整型数组指针

    delete p3;

    p3 = NULL;

  

    int (*p4)[3] = new int[2][3];//new 二维数组

    delete[]p4;//delete数组，加[]

    p4 = NULL;

  
  

    AA *p5=new AA;

    delete p5;

    p5 = NULL;

  

    int (*p4)[3] = new int[2][3];//new 二维数组

    delete[]p4;//delete数组，加[]

    p4 = NULL;

  
  

    AA *p5=new AA;

    delete p5;

    p5 = NULL;

    return 0;

}

```

  

　　*重点：整型数组指针、多维数组*

  

#### 引用

  

　　**引用**（`reference`​​）是C++对C的一个重要扩充。变量的引用就是变量的别名，因此引用又称**别名**。

  

```cpp

类型 &引用名 = 已定义的变量名

```

  

　　引用与其所代表的变量共享同一内存单元，系统并不为引用另外分配存储空间。实际上，编译系统使引用和其代表的变量具有相同的地址。

  

```c++

#include<iostream>

using namespace std;

  

int main()

{

    int a = 10;

    int& b = a;//&在定义时，是引用含义，作用：对这个变量对应的空间起的别名

    cout << a << " " << b << endl;

    cout << &a<< " " << &b << endl;

    a = 20;

    cout << a << " " << b << endl;

  

    //int&c=a;//必须定义就初始化

    //int*p;//可以不初始化

  

    int& c = a;//引用一旦定义（必须初始化）就不可更改

    int d = 40;

  

}

```

  

##### 注意

  

1. 必须定义就初始化

  

    * 引用并不是一种独立的数据类型，它必须与某一种类型的变量相联系。在声明引用时，必须立即对它进行初始化，不能声明完成后再赋值。

    * 为引用提供的初始值，可以是一个变量或者另一个引用。

2. 引用一旦定义（必须初始化）就不可更改

3. 指针是通过地址间接访问某个变量，而引用则是通过别名直接访问某个变量。

4. 对引用的进一步说明

  

    1. 不允许建立void类型的引用

    2. 不能建立引用的数组

    3. 不能建立引用的引用。不能建立指向引用的指针。引用本身不是一种数据类型，所以没有引用的引用，也没有引用的指针。

    4. 可以将引用的地址赋值给一个指针，此时指针指向的是原来的变量。  

        可以用const对引用加以限定，不允许改变该引用的值，但是它不阻止引用所代表的变量的值。

  

##### 引用作为函数参数、使用引用返回函数值

  

```cpp

#include <iostream>

using namespace std;

  

void swap(int &a, int &b)

{

    int t = a;

    a = b;

    b = t;

}

  

int a[] = {1, 3, 5, 7, 9};

  

int& index(int i)

{

    return a[i];

}

  

int main()

{

    int a = 5, b = 10;

    //交换数字a和b

    swap(a, b);

    cout << "a = " << a << " b = " << b << endl;

    cout << index(2) << endl;   //等价于输出元素a[2]的值

    index(2) = 100;             //等价于将a[2]的值赋为100;

    cout << index(2) << endl;

  

    return 0;

}

  

```

  

##### 出现冲突

  

```c++

#include<iostream>

using namespace std;

  

void fun(int a)

{

    cout << "void fun(int a) " << a << endl;

}

void fun(int& a)

{

    cout << "void fun(int &a) " << a << endl;

}

  

//定义函数指针!!!!!!!!!!!!!!!!!!!!!!!!!!!

void (*p1)(int) = &fun;

void (*p2)(int&) = &fun;

  
  

int main()

{

    int a = 10;

    int& e =a;

    //局部化 解决冲突

    void fun(int a);//出现冲突，把要调用的声明局部化，然后就会默认调用这个

    fun(e);

  

    //函数指针解决冲突

    cout << endl;

    (*p1)(e);

    (*p2)(e);

  

    return 0;

}

```

  

##### 解决冲突的两种方法

  

1. 局部化声明

2. 函数指针![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108906324.png)​

  

    ‍

  

　　‍

  

　　‍

  

　　[CSDN超细笔记](https://blog.csdn.net/weixin_44368437/article/details/117563488?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166778659716782395356479%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166778659716782395356479&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117563488-null-null.142^v63^control,201^v3^control_1,213^v1^control&utm_term=c%2B%2B&spm=1018.2226.3001.4187)

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108869979.png)​

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108808933.png)​

  

　　**对象**：描述其属性的数据以及对这些数据施加的一组操作封装在一起构成的统一体。对象可认为是数据+操作。

  

　　**类**：类是具有相同的数据和相同的操作的一组对象的集合。

  

　　消息传递：对象之间的交互。

  

　　**方法：**对象实现的行为称为方法。

  

　　面向对象程序设计的基本特征：抽象、封装、继承、多态。  

  

　　‍

  

## bool

  

```C++

#include<iostream>

#include<windows.h>

using namespace std;

  

int main()

{

    //typdef int BOOL;

    BOOL b = TRUE;//#define TRUE 1   ,#define FALSE 0

    cout << b << " " << sizeof(b) << endl;//1 4

    bool b = true;

    b = false;//true和false是cpp中的关键字

    cout << b << " " << sizeof(b) << endl;//1 1

    return 0;

}

```

  

### B00L和bool的区别：

  

1. bool,true,false为C+中提供的关键字，定义变量所需要的空间大小为1个字节

2. BOOL是一个int的别名(typedef),定义变量所需要的空间大小为4个字节，TRUE,FALSE为宏分别替换了整形数字1和0

  

## string

  

```c++

#include<iostream>

#include<string>//cpp字符串头文件，在比较新的版本中，iosteam中已经包含了string

using namespace std;

  

int main()

{

  

    string str1 = "1234";

    str1[1] = '9';

    cout << str1 << endl;

    str1 = "4321";

    cout << str1 << endl;

    string str2 = "4321";

    if (str1 == str2)//string类型的可以直接比较变量名，而char a[]是不可以的，因为变量名是地址

    {

        cout << "相同" << endl;

    }

    else

    {

        cout << "不相同" << endl;

    }

    for (int i = 0; i < str1.size(); i++)//变量名.size()  可以获得字符串的长度

    {

        cout << str1[i] << "  ";

    }

    cout << str1.size() << endl;

    cout << str1.length() << endl;//size()和length没有区别

    char* p="12345"

    cout << strlen(p) << endl;//strlen是返回char型字符串的函数

    return 0;

}

```

  

### 注意

  

1. string类型的可以直接比较变量名，而char a[]是不可以的，因为变量名是地址

2. 变量名.size() **方法**可以获得字符串的长度

3. 变量名.size() 和变量名.length() 没有区别

4. **区分:**strlen是返回char型字符串的函数

  

### string的方法

  

```C++

//string拼接

    string str3 = "123";

    string str4 = str3 + "456";

    cout << str4 << endl;

    str4 += "99";

    cout << str4 << endl;

  

//string截取

    string str5 = "123456789";

    string str6 =str5.substr(2,4);//截取字串,从2（#开始下标#）开始，截取4（#长度#）个

    /*

    当长度越界时，会合理优化

    当开始下标超限时，会报错

    */

    cout << str6 << endl;

  

//字符串转换

    const char *pp=str5.c_str();//将里面存储的字符串转换成const char*,-->适配c中已有的函数等

    cout << *pp << endl;

```

  

#### 要点

  

1. string拼接

  

   支持**+&quot;123&quot;**、**+char*字符串**、**+=**

2. string截取

  

   **string类型变量名.substr(开始下标,截取长度);**

  

   1. 当长度越界时，会合理优化

   2. 当开始下标超限时，会报错

3. 字符串转换

  

   **string类型变量名.c_str();**

  

   将里面存储的字符串转换成const char*

  

   作用：适配C语言中已有的函数等

  

## 增强型的for

  

```c++

#include<iostream>

using namespace std;

int main()

{

    int arr[5] = { 1,2,3,4,5 };

    for (int j = 0; j < 5; j++)

    {

        cout << arr[j] << " ";

    }

    cout << endl;

    //增强型的for

    for (int a : arr)

    {

        cout << a << " ";

    }

    cout << endl;

    //增强型的for不能遍历new出来的

    //增强型的for能遍历str

    string str("abcdefg");

    for (char a : str)

    {

        cout << a << " ";

    }

    cout << endl;

    return 0;

}

```

  

### 总结

  

　　增强的for循环这种遍历方式，适用于普通的数组、string、和支持begin, end操作的容器等

  

## nullptr

  

```c++

#include<iostream>

using namespace std;

  

void fun(int a)

{

    cout << "void fun (int a) " << a << endl;

}

  

void fun(int *p)

{

    cout << "void fun (int *p) " << p << endl;

}

  

void fun(char* p)

{

    cout << "void fun (int *p) " << p << endl;

}

  
  

int main()

{

    int* p = NULL;      //初始化为空，#define NULL 0

    fun(NULL);          //实际传过去的是 0，匹配的是 void fun(int a)

    fun((int*)NULL);    //传过去的才是NULL的地址，匹配的是 void fun(int *p)

    fun(10);

    //------------------------------------------------

    nullptr;//c++提供的关键字，具有明确的含义：空指针

    /*

        fun(nullptr);//传过去的是 空指针 ，匹配的是 void fun(int *p)

        但是，当void fun(int *p)和void fun(char *p),同时存在时，匹配不明确，会出现歧义

    */

    //所以只能强转

    fun((int*)nullptr);     //匹配void fun(int *p)

    fun((char*)nullptr);    //匹配void fun(char *p)

  

    fun((int*)NULL);        //匹配void fun(int *p)

    fun((char*)NULL);   //匹配void fun(char *p)

  

    return 0;

}

```

  

　　c++提供的关键字，具有明确的含义：空指针

  

　　*个人理解：nullptr是NULL的升级而不是扩展，所以可以使用nullptr直接取代NULL*

  

## ​​实参传递

  

```c++

#include<iostream>

using namespace std;

  
  

//void fun2(int a)//值传递

//{

//  a += 10;

//  cout << a << endl;

//}

void fun2(int* p)//地址传递

{

    *p += 10;

    cout << *p << endl;

}

void fun2(int& a)//引用传递

{

    a += 10;

    cout << a << endl;

}

  

int main()

{

    //fun2(aa);

    int bb = 10;

    fun2(&bb);

    cout << bb << endl;

    int cc = 10;

    fun2(cc);

    cout <<cc<< endl;

  

    return 0;

}

```

  

## 三种传递的比较

  

|方法|值传递|地址传递|引用传递|

| --------| --------------------------| ----------------------------------| ----------------|

|代码风格|void fun(int a)|void fun(int* p)|void fun(int &a)|

|调用方法|fun(num);|fun(&num);|fun(num);|

|空间利用|将实参赋值一份，占空间较大|生成一个地址，占用空间较小（可控）|占用空间最小|

|**能否**修改实参|不能|能|能|

  

## 友元函数

  

　　注意

  

1. 友元函数是**独立于当前类的外部函数**，

2. 一个友元函数**可以同时定义为两个类的友元函数**

3. 友元函数既可以在类的内部，也可以在**类的外部定义**；

4. **在外部定义友元函数时，不必加关键字friend**

5. **友元关系不能被继承**，基类的友元对派生类没有特殊的访问权限。

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1664032312261.png)​

  

　　‍

  

# 02类基础

  

## 类的构成

  

　　类声明中的内容包括数据和函数，分别称为数据成员和成员函数。按访问权限划分，数据成员和成员函数又可分为共有、保护和私有3种。

  

```cpp

class 类名{

    public：

        公有数据成员；

        公有成员函数；

    protected:

        保护数据成员；

        保护成员函数；

    private:

        私有数据成员；

        私有成员函数；

};

  

```

  

#### 注意

  

1. 类名一般大写C开头

2. 类成员属性一般以 m_ + 数据类型 + 变量名

3. 定义一个对象（类的实例化）,这时才会为对应的这个类开辟空间

  

　　对一个具体的类来讲，类声明格式中的3个部分并非一定要全有，但至少要有其中的一个部分。一般情况下，一个类的数据成员应该声明为私有成员，成员函数声明为共有成员。这样，内部的数据整个隐蔽在类中，在类的外部根本就无法看到，使数据得到有效的保护，也不会对该类以外的其余部分造成影响，程序之间的相互作用就被降低到最小。  

  

* 类声明中的关键字private、protected、public可以任意顺序出现。

* 若私有部分处于类的第一部分时，关键字private可以省略。这样，如果一个类体中没有一个访问权限关键字，则其中的数据成员和成员函数都默认为私有的。

* 不能在类声明中给数据成员赋初值。

  

```c++

#include<iostream>

#include<string>

using namespace std;

  

class CPeople{//类名一般大写C开头

public:

    string m_strName;//类成员属性一般以 m_ + 数据类型 + 变量名

    bool m_bSex;

    int m_nAge;

  

    void run() {

        cout << m_strName << "在跑步" << endl;

    }

};

  
  

int main()

{

    CPeople peo;//定义一个对象（类的实例化）,这时才会为CPeople这个类开辟空间

    peo.m_strName = "小明";

    cout << peo.m_strName << endl;

  
  

    return 0;

}

```

  

## 访问修饰符

  

```c++

class CPeople{//类名一般大写C开头

    /*

    访问修饰符(3种)：描述了类中的成员的适用范围，即访问控制（访问权限）

    pub1ic:修饰的成员在类内、类外只要能定义对象的地方都可以使用，

    protected::修饰的成员在类内和继承中的子类中可以使用。

    private:修饰的成员只能在类内去使用。

    */

public:

    string m_strName;//类成员属性一般以 m_ + 数据类型 + 变量名

protected:

    bool m_bSex;

private:

    int m_nAge;

public:

    void run() {

        cout << m_strName << "在跑步" << endl;

    }

    //---公共接口------

    /*

    公共接口存在的意义，可以在对类内私有数据做修改时，进行限制，避免随意修改

    */

    int GetAge()

    {

        return m_nAge;

    }

    void SetAge(int num)

    {

        if (num >= 0 && num <= 200)

        {

            m_nAge = num;

        }

    }

};

  

int main()

{

    CPeople peo;//定义一个对象（类的实例化）,这时才会为CPeople这个类开辟空间

    peo.m_strName = "小明";

    cout << peo.m_strName << endl;

    peo.SetAge(20);

    cout << peo.GetAge() << endl;

  

    return 0;

}

```

  

#### 访问修饰符描述

  

　　  *描述了类中的成员的适用范围，即访问控制（访问权限）*

  

1. **public**:修饰的成员在类内、类外只要能定义对象的地方都可以使用，

2. **protected**::修饰的成员在类内和继承中的子类中可以使用。

3. **private**:修饰的成员只能在类内去使用。

  

# 03对象

  

## 对象种类

  

### 全局对象（例如：全局的CTest tst；)

  

1. **生命周期**，从程序创建开始（在主函数执行前就会创建对象），一直到程序退出

2. **作用域**：整个应用程序（可跨文件使用）

  

### 静态全局（例如：全局的static CTest tst2;)

  

1. **生命周期**，从程序创建开始（在主函数执行前就会创建对象），一直到程序退出

2. **作用域**：具有文件作用域，可以在当前文件中直接使用，跨源文件不能直接使用。

  

### 静态局部对象（例如：局部的/函数内的static CTest tst2;)

  

1. 第一次调用该函数且执行了定义对象的代码，才会别创建，一直到程序退出

2. 多次调用函数，并不会创建多个静态局部对象

3. 在当前函数范围内可以直接使用，出了当前函数就不能直接使用了。出了函数外，可以通过对应的**指针**，间接使用静态局部

  

## 类的成员

  

### 类所占据的空间

  

　　空类中1个字节，占位作用，标识当前对象真实存在与内存空间中，区别于其他对象。

  

　　有成员属性后，按照属性所占空间分配。

  

### 成员属性和成员函数

  

1. 一般的成员属性：属于对象，会占用对象的内存空间，定义对象的时候，定义多个对象会存在多份成员属性

2. 成员函数：属于类的，占用的是应用程序的空间，编译期存在，一个类只有一份，与是否定义对象无关，多个对象共享函数

  

||所属|所占空间|份数|

| :-------| :---| :-------| :---------------------------------------------------|

|成员属性|对象|对象|与定义的对象数相关|

|成员函数|类|应用程序|一个类只有一份，与是否定义对象无关，多个对象共享函数|

  

```c++

#include<iostream>

using namespace std;

  

class CTest {

public:

    int m_a;

    CTest() {

    }

    void show() {

        cout << "shuow" << endl;

    }

    void showA() {

        cout << "shuow" << " "<<m_a << endl;

    }

};

  

int main()

{

    cout << sizeof(CTest) << endl;//空类 1个字节（占位标识符），有成员属性后，按照属性所占空间分配

    CTest* p = nullptr;

    //cout << p->m_a << endl;类不具体化成对象时，类中的成员属性并不存在，所以会报错

    p->show() ;//类中的成员函数，存在，并且在 具体化对象后 也不占用对象的空间

    //p->showA();//函数中用到了属性，所以也会出错

  

    return 0;

}

```

  

## this指针

  

1. 类中的**非静态****成员函数**会有一个隐藏的参数，为this指针，这才是实际上该函数的第一个参数

2. this指针的**作用**：连接当前调用该函数的对象和函数，在函数中使用其他成员都是使用this调用的

  

   **起桥梁作用，在类中可以无感知的使用类成员（成员属性、成员函数）**

3. 编译器会默认为我们添加this指针

  

```c++

#include<iostream>

using namespace std;

  

class CTest {

public:

    int m_a;

    CTest() {

  

    }

    void show() {

        cout << "shuow" << endl;

    }

    //类中的非静态成员函数会有一个隐藏的参数，为this指针，这才是实际上该函数的第一个参数

    //this指针的作用：连接当前调用该函数的对象和函数，再函数中使用其他成员都是使用this调用的

    void showA(/*CTest * const this */) {

        cout << "shuow" << " "<<m_a << endl;//等效下面一行，编译器自动添加了 this

        //cout << "shuow" << " "<<this->m_a << endl;

        show();//等效于

        //this->show();

    }

};

  

int main()

{

    cout << sizeof(CTest) << endl;//空类 1个字节（占位标识符），有成员属性后，按照属性所占空间分分配

    CTest* p = nullptr;

    //cout << p->m_a << endl;类不具体化成对象时，类中的成员属性并不存在

    p->show() ;//类中的成员函数，存在，并且不占用对象的空间

    //p->showA();//函数中用到了属性，所以也会出错

  

    return 0;

}

```

  

## 静态成员(static)

  

### 静态成员初始化

  

　　类中的静态成员初始化，需要写在类外，格式  类型 类名:: 变量名 = 初始化值  注意：去掉static  

分文件编写的时候，写在.cpp中

  

```c++

#include<iostream>

using namespace std;

  

/*

静态成员属性：属于类，，不包含在对象的内存空间中，编译期存在，与对象存在与否无关

*/

class CTest {

public:

    static int m_a;//静态成员属性

    int m_b;

    CTest() {

        m_a = 10;//赋值，不是初始化

        m_b = 20;//初始化

        cout << m_a << endl;

    }

    static void fun(){/*没有隐藏的指针this，就不能使用普通成员属性和成员函数*/

        cout << "static void fun()" << endl;

    }

};

/*

类中的静态成员初始化，需要写在类外，格式  类型 类名:: 变量名 = 初始化值  注意：去掉static

分文件编写的时候，写在.cpp中

*/

int CTest::m_a = 30;//初始化

  

/*

静态成员的使用，可以通过对象也可以不通过对象

*/

int main()

{

    CTest tst1;

    cout << tst1.m_a << endl;

    cout<<CTest::m_a;   //在没有对象的情况下，类名作用域直接使用

    CTest tst2;

    cout << &tst1.m_a << " " << &tst2.m_a << endl;

  

    //通过对象去修改静态成员属性，对其他对象是可见的（使用的是修改之后的值）

    tst1.m_a = 100;

    cout << tst2.m_a << endl;

  

}

```

  

### 静态成员属性

  

1. 特点

  

   属于类的，不包含在对象的内存空间中，编译期存在，与对象存在与否无关，一个类中只有一份，多个对象共享

2. 初始化

  

   需要写在类外进行初始化，格式类型类名：：变量名=初始化值，注意：去掉关键字static

3. 调用

  

   可以通过对象去使用，也可以不通过对象类名作用域直接使用

  

### 静态成员函数

  

1. 特点

  

   属于类的，在编译期存在，一个类只有一份，多个对象共享这一份函数

  

### 和普通的成员函数区别：

  

1. 本质区别

  

   静态成员函数没有隐藏的this指针，就不能使用普通成员属性和成员函数，只能使用静态的成员。

2. 调用

  

   静态成员函数是否通过对象都可以调用，普通的成员函数必须通过对象去调用。

  

## 常量指针和指针常量

  

### 定义

  

```c++

#include<iostream>

using namespace std;

int main()

{

    int m_a = 10;

    const int m_b = 20;

  

    //常量指针,通过指针 值不课改，可改指向

    const int* p1 = &m_a;//或者 int congst * p1 =&m_a;

    //*p1 = 30;非法操作

    p1 = &m_b;

  

    //指针常量， 通过指针 值可改，指向不可改

    int* const p2 = &m_a;//初始化必须赋值

    *p2 = 40;

    //p2 = &m_b;非法操作

  
  

    //常量指针常量,不能修改指向，！不能通过！指针改值

    const int* const p3 =& m_a;

    //*p3=100;

    //p = &m_b;

    m_a = 100;//合法

  

}

```

  

### 常量指针和指针常量的比较

  

|类型|格式|值|指向|特点|

| ------------| ---------------------------------------------------------| ------| ------| --------------------|

|常量指针|const int* p1 ;//或者int const * p1;<br />const int* p1 = &m_a;|不可改|可改||

|指针常量|int* const p2 = &m_a;|可改|不可改|创建的时候就要初始化|

|常量指针常量|const int* const p3 =& m_a;|不可改|不可改||

  

### 指针安全级别问题

  

```c++

const int*p3=&ma;//安全级别升级的操作

  

int* const p4 = &mb; // &mb = const int*, 指针的安全级别是降级操作，不允许

  

*p4=60;

```

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108934482.png)

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108948399.png)

  

## 常函数

  

```c++

#include<iostream>

using namespace std;

  

class CTest {

public:

    int m_a;

    const int m_b;

    static int m_c;

  

    CTest():m_a(10), m_b(20) {

    }

    void show(/*CTest const this */) {

        this->m_a = 40;

        fun();

        //或者this->fun();

        /*相当于

        CTest tst;

        CTest* const pthis2 =& tst;

        const CTest* const pthisl = pthis2; // 指针的安全级别升级操作，允许的

        */

    }

    /*

    区别：this指针类型不同，对于常函数来说有双重const修饰，在常函数中不能修改类中的非静态成员属性，

    常含数不能调用普通函数，但是可以调用静态函数

    */

  
  

    /*常函数，在参数列表后面加const, const修饰了* this, 意味着this指针指向的对象里的成员属性不能修改*/

    /*const */void fun(/*const CTest*const this *//*const int a*/)const {

        cout << m_a << " " << m_b << endl;

        // ma = 30;//即使是变量也不能在常函数中修改

        //mb=40:

        //this->m_a=20;不可修改

        this->m_a;

        this->m_b;

  

        m_c = 50;//可以修改静态成员，因为静态成员可以不用this调用

  

        //this->show();

        //show();

        /*相当于

        CTest tst;

        const CTest*const pthisl =&tst;

        CTest*const pthis2 pthis1://指针的安全级别降级操作，不允许

        */

    }

};

int CTest::m_c = 30;

  

int main()

{

    //int m_a = 10;

    //const int m_b = 20;

  

    //const int*p3=&ma;//安全级别升级的操作

    // int* const p4 = &mb; // &mb = const int*, 指针的安全级别是降级操作，不允许

    //*p4=60;

  

    return 0;

}

```

  

### 特点

  

1. 常函数，**在参数列表后面加const**, const修饰了* this, 变成了   `const CTest*const this`   意味着this指针指向的对象里的成员属性不能修改，即使是变量也不能在常函数中修改。

2. 与普通函数的区别：this指针类型不同，对于常函数来说有双重const修饰，在常函数中不能修改类中的非静态成员属性，**常含数不能调用普通函数，但是可以调用静态函数（因为静态成员可以不用this调用）**

3. **分文件编写时候，定义时，const不能省略**

  

# 04继承

  

## 类之间的关系

  

　　类之间的横向关系

  

### 组合（复合）

  

　　它是一种"is a part of"的关系，部分与整体，包含与被包含。组合是一个类中包含另一个类对象。相比聚合，组合是一种强所属关系，**组合关系的两个对象往往具有相同的生命周期**，被组合的对象是在组合对象创建的同时或者创建之后创建，在组合对象销毁之前销毁。一般来说被组合对象不能脱离组合对象独立存在，整体不存在，部分一定不存在。

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E5%90%88.png)

  

　　举例：人与手、人与头之间的关系，人需要包含头和手，头、手是人的一部分且不能脱离人独立而存在。

在C+语法中，通常在组合类中包含被组合类对象来实现组合关系：

  

```c++

class CHand{};

class CPeople{

    CHand m hand;//组合（复合）关系

}

```

  

### 依赖

  

　　它是一种"use a"的关系。一个对象的某种行为依赖于另一个类对象，被依赖的对象视为完成某个功能的工具，并不持有对他的引用，只有在完成某个功能的时候才会用到，而且是必不可少的。**依赖之间是没有生命周期约束关系的。**

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/image-20220826170956737.png)

  

　　举例：人要完成编程这件事，那么需要用到电脑，电脑作为一个工具，其他的时候不需要，电脑也不可能作为人的属性而存在（非组合关系），人必须依赖于电脑才能完成编程这件事。

C++语法中，代码的表现形式为多种，通常将被依赖的对象作为另一类方法的参数的形式实现两个类之间的依赖关系。

  

```c++

class CComputer{};

class CPeople{

    void Code(CComputer *pc)//或：CComputer &pc,

};

```

  

### 关联

  

　　它是一种"has a"的关系。关联不是从属关系，而是**平等关系，可以拥有对方，但不可占有对方**。完成某个功能与被关联的对象有关，但是可有可无。**被关联的对象与关联的对象无生命周期约束关系**，被关联对象的生命周期由谁创建就由谁来维护。只要二者同意，可以随时解除关系或是进行关联，被关联的对象还可以再被别的对象关联，所以关联是可以共享的。

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/image-20220826171034226.png)

  

　　举例：人和朋友的关系，人要完成玩游戏这个功能，没有朋友可以自己玩游戏，如果交到朋友了就可以和朋友一起玩游戏。

C++语法中，通常在关联的类中定义被关联类对象的指针形式实现两个类之间的关联关系。

  

```c++

class CFriend{};

class CPeople{

    CFriend*m pFriend;//关联关系

}

```

  

### 聚合

  

　　它是一种"owns a"的关系。多个被聚合的对象聚集起来形成一个大的整体，聚合的目的是为了统一进行管理同类型的对象，**聚合是一种弱所属关系**，**被聚合的对象还可以再被别的对象关联**，所以**被聚合对象是可以共享的**。虽然是共享的，聚合代表的是一种更亲密的关系，相当于强版本的关联。

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/image-20220826171052974.png)

  

　　举例：一堆人组成一个家庭，进行统一管理完成敲代码工作。

C++语法中，通常在聚合类中定义被聚合对象指针的数组、链表等容器。

  

```c++

class CPeople{};

class CFamily{

    CPeople*m_pFamily [10];

}

```

  

### 代码

  

```c++

#include<iostream>

using namespace std;

  
  

class CHand {

public:

    void move() {

        cout << "我的手在移动" << endl;

    }

};

class CComputer {

public:

    void compile() {

        cout << "电脑正在编译代码   生成可执行程序" << endl;

    }

};

  

class CFriend {

public:

    void play() {

        cout << "我的朋友正在玩耍" << endl;

    }

};

  
  

class CPeople {

public:

    CHand m_hand;

    CFriend* m_pFri;

public:

    void clap() {

        m_hand.move();

        cout << "手掌撞击   发出掌声" << endl;

    }

    void code(CComputer* pCom) {

        if (pCom) {

            m_hand.move();

            cout << "敲出一行行代码...." << endl;

            pCom->compile();

        }

        else {

            cout << "我无法完成敲代码的功能" << endl;

        }

    }

    void palyWangZhe() {

        if (m_pFri) {//有朋友

            cout << "找朋友组队.." << endl;

            m_pFri->play();

            cout << "我和我的朋友一起打王者，victory" << endl;

        }

        else {//没朋友

            cout << "我和自己打王者，victory" << endl;

        }

    }

};

  
  

class CFamily {

public:

    CPeople* m_arrPro[10];

    CFamily() {

        for (CPeople*& peo : m_arrPro) {

            peo = nullptr;

        }

        m_arrPro[0] = new CPeople;

        m_arrPro[1] = new CPeople;

        m_arrPro[2] = new CPeople;

    }

    ~CFamily() {

        for (CPeople*& peo : m_arrPro) {

            if (peo) {

                delete peo;

                peo = nullptr;

            }

        }

    }

public:

    void AllPeopleCode(CComputer* pCom) {

        for (CPeople* peo : m_arrPro) {

            if (peo) {

                peo->code(pCom);

            }

        }

    }

};

  
  
  

int main()

{

    {

        //组合

        CPeople peo;

        peo.clap();

        cout << endl;

    }

  

    {

        //依赖

        CComputer* pCom = new CComputer;

        CPeople peo;

        peo.code(pCom);

  

        delete pCom;//回收电脑

        pCom = nullptr;

  
  

        peo.code(pCom);//此时没有电脑

    }

  

    {

        //关联

        CPeople peo;

        peo.palyWangZhe();

  

        CFriend* pFri = new CFriend;

        peo.m_pFri = pFri;//结交朋友

        peo.palyWangZhe();

  

        peo.m_pFri = nullptr;//和朋友绝交

        peo.palyWangZhe();

  

        delete pFri;

        pFri = nullptr;

  
  

    }

  

    {

        //聚合

        CComputer comp;

        CFamily fam;

        fam.AllPeopleCode(&comp);

    }

  

    return 0;

}

```

  

## 类的继承

  

### 定义

  

　　子类包含且可以使用父类的成员

  

```c++

#include <iostream>

using namespace std;

//继承：子类包含且可以使用父类的成员

class CFather {

public:

    int m_a;

    int m_money;

    CFather() {

        m_money = 100;

    }

};

  

class CSon :public CFather {

public:

    int m_b;

    int m_money;

    CSon() {

        m_a = 10;

        m_b = 20;//子类可以直接使用父类的成员

        m_money = 200;

    }

    void show() {

        cout << m_a << " " << m_b << endl;

        cout << CSon::m_money << endl;//当子类成员和父类成员同名时，在成员前面加上作用域得以区分，默认是子类

        cout << CFather::m_money << endl;

    }

  

};

  

int main()

{

    CSon p1;

    p1.show();

    cout << endl;

    cout << p1.m_money << endl;

    cout << p1.CSon::m_money << endl;

    cout << p1.CFather::m_money << endl;//显示指定

    return 0;

}

```

  

### 子类与父类成员同名时

  

　　当子类成员和父类成员同名时，在成员前面加上作用域得以区分（默认是子类）

  

### 当一个类包含另一个类的对象

  

```c++

#include <iostream>

using namespace std;

class CStepFather {

public:

    int m_a;

    CStepFather() {

        m_a = 10;

    }

    CStepFather(int a) {

        m_a = a;

    }

};

  

class CSon {

public:

    CStepFather m_stepFa;//包含另一个类的对象

    int m_son;

public:

    CSon() /*：m_stepFa() */ { // 当包含另一个类的对象，编译器会自动调用无参的构造进行初始化

        m_son = 20;

    }

    CSon(int a) :m_stepFa(a) {//如果想调用带参数的构造函数进行初始化，需要手动显式指定

        m_son = 20;

    }

    CSon(int a, int b) :m_stepFa(a) {

        // 如果另一个类中没有无参的构造函数，必须显式的指定带参数的构造函数，如果什么也不指定，会报错

        m_son = 20;

    }

};

  
  
  

int main() {

    CSon son;

    cout << son.m_son <<"  "<<son.m_stepFa.m_a << endl;

    CSon son2(100);//匹配的是CSon和CStepFather的带参数的构造函数

    cout << son2.m_son <<"   "<<son2.m_stepFa.m_a << endl;

    return 0;

}

```

  

1. 当包含另一个类的对象，编译器会自动调用无参的构造进行初始化

2. 如果想调用带参数的构造函数进行初始化，需要手动显式指定

3. 如果另一个类中没有无参的构造函数，必须显式的指定带参数的构造函数，如果什么也不指定，会报错

  

### 继承中构造和析构的顺序

  

#### 构造顺序

  

　　真父类->假父类->子类

  

#### 析构顺序

  

　　**和构造的顺序相反**

  

　　先析构在回收对象

  

　　析构子类->回收子类---->析构假父类->回收假父类---->析构父类->回收父类

  

### 继承的优点

  

　　继承的优点：将功能比较相似的类里面的公共的成员、方法等，单独抽离出来形成一个类，这个类就作为**父类**，各个子类继承这个父类，只维护了父类中的一份公共的代码，无论增加还是修改公共的方法，只需要修改一份即可，当增加新的子类只需要继承父类，这些公共的方法也就继承了也可以使用了，**提高了程序代码的复用性、扩展性，灵活性。**

  

## 继承方式

  

　　public  、protected、private, 和 访问修饰符共同决定了父类中的成员在子类中的使用范围，所表现属性 及  访问控制

  

### 继承方式：public

  

|父类成员属性|子类成员属性|

| ------------| ------------|

|public|public|

|protected|protected|

|private|不可访问|

  

### 继承方式：protected

  

|父类成员属性|子类成员属性|

| ------------| ------------|

|public|protected|

|protected|protected|

|private|不可访问|

  

### 继承方式：private

  

|父类成员属性|子类成员属性|

| ------------| ------------|

|public|private|

|protected|private|

|private|不可访问|

  

### 默认继承方式

  

　　private私有继承

  

## 隐藏

  

　　子类中出现和父类中同名的函数，会隐藏父类中的函数。这种关系叫**隐藏**。

  

　　若想使用父类中的函数，可以**加上类名作用域**。

  

## 父类指针直接指向子类对象

  

```c++

#include<iostream>

using namespace std;

  

void show(int a) {

    cout <<"show(int a)" << a << endl;

}

  

void show(char a) {

    cout << "show(char a)" << a << endl;

}

  

class A {

public:

    void show(/*  A * const this   */int a, int b) {  //和子类中同名的成员的关系可以称之为：隐藏

        cout << "A::show(int a, int b) " << a << "    " << b << endl;

    }

};

  

class AA:public A {

public:

    void show(int a) {

        cout << "AA::show(int a)" << a << endl;

    }

    //也是函数重载

    void show(char a) {

        cout << "AA::show(char a)" << a << endl;

    }

};

  
  

int main() {

    show(10);   //可以根据实参自动匹配对应的重载函数

    show('a');

  

    /*AA aa;

    aa.show(10);

    aa.show('b');*/

    //aa.show(10,20);    //想去匹配父类的函数，但无法自动匹配，不是函数重载，因为不在一个作用域下

    //-----------------------------------

    //AA aa;

    //aa.show(10, 20);  //子类的同名的函数注释掉，可以匹配父类的函数了

  

    AA aa;

    aa.A::show(10,20);   //显式指定父类的show函数

  

    A* pthis = &aa;  //继承下，父类的指针不通过强转可以直接指向子类对象

    //保证了用子类的对象可以成功的调用父类的非静态成员函数,

    //除此之外，还可以利用这个特性：统一多种子类类型

  

    return 0;

}

```

  

　　**继承下，父类的指针不通过强转可以直接指向子类对象**

  

　　保证了用子类的对象可以成功的调用父类的非静态成员函数,

除此之外，还可以利用这个特性：统一多种子类类型

  

## 调用函数的三种方法

  

```c++

#include<iostream>

using namespace std;

  

/*

函数指针的优点：函数指针可以指向不同模块但是功能相似的函数，利于系统抽象、降低耦合度，接口和函数分离，提高代码复用性、

拓展性

*/

  

void show() {

    cout << "show()" << endl;

}

  
  
  

int main() {

    show(); //函数名调用

  

    void(*p)() = &show;x

    (* p)();//通过函数指针间接调用函数

  

    typedef void(*P_FUN)();//优化函数指针

    P_FUN p2 = &show;//void(*p2)() = &show;

    (*p2)();

}

```

  

## typedef优化函数

  

```c++

typedef void (CPeople::* P_FUNN)();

  

// P_FUNN  ==== void (CPeople::* )()

  

void Show(CPeople* pPeo, P_FUNN p_fun) {

    pPeo->Cost(20);

    //pPeo->Eat();

    (pPeo->*p_fun)();

    pPeo->Play();

}

```

  

## 类成员函数指针

  

```c++

#include<iostream>

using namespace std;

void show() {

    cout << "show" << endl;

}

class  CTest {

public:

    void show(/* CTest const this */) {

        cout << "CTest::show" << endl;

        cout << "this" << endl;

    }

  

};

/*

区别：

1.作用域不同。

2.非静态类成员函数有隐藏的this指针，全局的函数没有

*/

  

int main() {

  

    CTest tst;

    tst.show();

  

    //void (*p_fun)() = &tst.show;//这是一个错误的写法

    //void (*p_fun)() = &CTest::show;//无法从“void(CTest ::*)(void)” 转换为 “void(*)(void)”

    // 类成员函数指针，C ++ 中提供的一个整体操作  ::* ，用来定义类成员函数指针

    void (CTest :: * p_fun)() = &CTest::show;

    (tst .* p_fun)();///.*、->*c+中提供的一个整体操作，通过对象调用类成员函数指针指向的类成员函数

  
  

    CTest* pTst = new CTest;

    (pTst->*p_fun)();

  

    cout << pTst << endl;

  
  

    return 0;

  
  

}

```

  

## 使用类成员函数指针实现多态

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108978957.png)

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662108990455.png)

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662109003719.png)

  

# 05多态

  

## 多态

  

### 概念

  

　　**多态**  

多种形态，相同的行为导致了不同的结果，同一行语句展现了多种不同的表现形态，即多态  

父类的指针可以指向任何继承于该类的子类对象，多种子类对象具有多种形态，由父类的指针统一管理，  

父类的指针则具有多种形态，即是多态。

  

### 多态的条件

  

1. 在**继承**下，父类指针指向子类对象（或者**引用**形式，如`CFather& fa = son; //引用形式的多态`​本质还是父类指针指向子类对象）

2. 父类存在虚函数，子类重写虚函数

  

### 什么叫虚函数

  

　　`virtual`虚函数关键词

  

　　例如

  

```C++

virtual void show() {

        cout << "CFather::virtual void show()" << endl;

    }

```

  

### 什么叫“重写”

  

　　子类定义和父类虚函数一模一样(函数名，参数，返回类型)的虚函数。

  

　　**virtual在父类虚函数必须写，在子类处可以不写**

  

```c++

/*多态

多种形态，相同的行为导致了不同的结果，同一行语句展现了多种不同的表现形态，即多态

父类的指针可以指向任何继承于该类的子类对象，多种子类对象具有多种形态，由父类的指针统一管理，

父类的指针则具有多种形态，即是多态。

*/

  

/*多态的条件

1. 在继承下，父类指针指向子类对象

2.父类存在虚函数，子类重写虚函数

*/

  
  

/*什么叫“重写”

子类定义和父类虚函数一模一样(函数名，参数，返回类型)的虚函数

*/

  

#include<iostream>

using namespace std;

class CFather {

public://virtual虚函数关键词

    virtual void show() {

        cout << "CFather::virtual void show()" << endl;

    }

};

  

class CSon :public CFather {

public:

    virtual void show() {

        cout << "CSon::virtual void show()" << endl;

    }

};

  

int main() {

    CFather* pFa = new CSon;

    pFa->show();

    return 0;

}

```

  

## 子类的虚函数列表

  

　　继承多态下，子类的虚函数列表：

  

1. 子类不但继承父类的成员，也会继承父类的虚函数列表。

2. 会检查子类中是否有重写的父类的虚函数，如果有就原位置替换如果没有父类的虚函数得以保留。

3. 子类中独有的虚函数，按照顺序依次在虚函数列表的后面添加。

4. 覆盖：子类的虚函数列表中，子类虚函数会替换掉父类的虚函数（重写），这个动作称之为覆盖

  

```c++

#include<iostream>

using namespace std;

  
  

class CFather {

public:

    virtual void fun1() {

        cout << "CFather::fun1()" << endl;

    }

    virtual void fun2() {

        cout << "CFather::fun2()" << endl;

    }

};

  

class CSon :public CFather{

public:

    virtual void fun1() {

        cout << "CSon::fun1()" << endl;

    }

    virtual void fun3() {

        cout << "CSon::fun3()" << endl;

    }

};

class CSon2 :public CFather {

public:

    virtual void fun1() {

        cout << "CSon2::fun1()" << endl;

    }

};

  

/*继承多态下

*虚函数指针指向哪个类的虚函数在列表，取决于定义哪个类的对象（new哪个子类）

*/

  
  

/*继承多态下，子类的虚函数列表：

1.子类不但继承父类的成员，也会继承父类的虚函数列表。

2.会检查子类中是否有重写的父类的虚函数，如果有就原位置替换

如果没有父类的虚函数得以保留。

3.子类中独有的虚函数，按照顺序依次在虚函数列表的后面添加。

4. 覆盖：子类的虚函数列表中，子类虚函数会替换掉父类的虚函数（重写），这个动作称之为覆盖

*/

int main() {

    CFather* pFa1 = new CFather;//虚函数指针指向 父类CFather 的虚函数列表

  

    CFather* pFa2 = new CSon;//虚函数指针指向 子类CSon 的虚函数列表

    CFather* pFa3 = new CSon2;//虚函数指针指向 子类CSon2 的虚函数列表

  

    CSon son;

    /*

    [0]:CSon::fun1

    [1]:CFather:fun2

    */

    pFa2->fun1();

    pFa2->fun2();

    ((CSon*)pFa2)->fun3();

  

    return 0;

}

```

  

### 注意

  

　　继承多态下虚函数指针指向哪个类的虚函数列表，取决于定义哪个类的对象（new哪个子类）

  

### 特殊情况

  

```c++

#include <iostream>

using namespace std;

  

class CFather

{

public:

    virtual void fun1()

    {

        cout << "Father::fun()1" << endl;

    }

    virtual void fun2()

    {

        cout << "Father::fun()2" << endl;

    }

};

  

class CSon : public CFather

{

public:

    virtual void fun1()

    {

  

        cout << "Son::Pfun()1" << endl;

    }

  

    virtual void fun3()

    {

        cout << "Son::fun()3" << endl;

    }

};

  

typedef void (*P_FUN)();

  

int main()

{

    CFather* pFa = new CSon;

    pFa->fun1();

    pFa->fun2();

    ((CSon *)pFa)->fun3();

    cout << endl;

    //------------------------------

  

    int a = *(int*)pFa; //_vptr

    P_FUN p_fun1 = (P_FUN)(((int*)a)[0]);

    P_FUN p_fun2 = (P_FUN)(((int*)a)[1]);

    P_FUN p_fun3 = (P_FUN)(((int*)a)[2]);

    (*p_fun1)();

    (*p_fun2)();

    (*p_fun3)();

  
  

    CSon son;

    CFather& fa = son; //引用形式的多态

    fa.fun1();

    fa.fun2();

    cout << 1 << endl;

  

    return 0;

}

```

  

　　当子类中有独属于子类的函数的时候，指向子类的父类指针就无法访问子类的这个成员函数。

  

#### 解决方法

  

1. 强转 `((CSon *)pFa)->fun3();`

2. 手动模拟虚函数指针的方式访问。

  

   ```C++

  

   typedef void (*P_FUN)();

  

   int a = *(int*)pFa; //_vptr

       P_FUN p_fun1 = (P_FUN)(((int*)a)[0]);

       P_FUN p_fun2 = (P_FUN)(((int*)a)[1]);

       P_FUN p_fun3 = (P_FUN)(((int*)a)[2]);

       (*p_fun1)();

       (*p_fun2)();

       (*p_fun3)();

   ```

  

   注意：将指针强制转成int型只能在x86平台下（在x64平台下，用long接收），否则会出现**-Wint-to-pointer-cast**

  

## 虚函数

  

　　注意

  

　　分文件编写时，定义时，virtual不写

  

### 虚函数指针

  

　　存在一个虚函数指针_vfptr，类型为`void**`

属于对象的二级指针，在对象内存空间的首地址

定义多个对象，虚函数指针会存在多份，但是多个对象的虚函数指针指向的是同一个地址（虚函数列表）

  

　　_vfptr 是编译期 默认给加到类中的 成员属性，在定义对象时，在构造的初始化参数列表中由编译器自动进行初始化，指向虚函数列表

  

#### 虚函数列表

  

　　编译期存在，属于类，只有一份，为多个对象的虚函数所共用

存放类中虚函数的地址的空间

按照类中声明顺序排布，以数组的形式呈现，每个元素为虚函数的地址

  

　　**必须由真实的类调用**

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662109105677.png)

  

### 虚函数的调用流程

  

　　​ 1. 找到对象内存空间首地址指针大小的一块空间（_vfptr），

​   2. 通过它间接引用 找到虚函数列表（数组），

​   3. 通过下标定位匹配对应的虚函数地址，在通过这个地址调用虚函数。

  

### 普通函数的调用流程

  

　　​ 通过函数名（即为函数的入口地址），然后直接跳转执行函数

  

### 虚函数和普通函数的区别

  

　　​ 1. 本质区别：函数调用流程不同

​   2. 效率不同：普通函数性能强，虚函数性能弱

​   3. 使用场景不同：虚函数可以实现多态，普通函数不能

  

```c++

#include<iostream>

using namespace std;

class CTest {

public:

    int m_a;

    void fun() {//函数属于类，而不属于对象

        cout << "CTest fun()" << endl;

    }

    /*_vfptr虚函数指针

     存在一个虚函数指针，类型为void**

     属于对象的二级指针，在对象内存空间的首地址

    定义多个对象，虚函数指针会存在多份，但是多个对象的虚函数指针指向的是同一个地址（虚函数列表）

    _vfptr 是编译期 默认给加到类中的 成员属性，在定义对象时，在构造的初始化参数列表中由编译器自动进行初始化，指向虚函数列表

    */

    /*虚函数列表

    编译期存在，属于类，只有一份，为多个对象的虚函数所共用

    存放类中虚函数的地址的空间

    按照类中声明顺序排布，以数组的形式呈现，每个元素为虚函数的地址

    */

  
  

    /*虚函数的调用流程

    1. 找到对象内存空间首地址指针大小的一块空间（_vfptr），

    2. 通过它间接引用 找到虚函数列表（数组），

    3. 通过下标定位匹配对应的虚函数地址，在通过这个地址调用虚函数。

    */

  

    /*普通函数的调用流程

    通过函数名（即为函数的入口地址），然后直接跳转执行函数

    */

  

    /*虚函数和普通函数的区别

    1. 本质区别：函数调用流程不同

    2. 效率不同：普通函数性能强，虚函数性能弱

    3. 使用场景不同：虚函数可以实现多态，普通函数不能

    */

  

    virtual void fun2() {

        cout << "CTest virtual fun2()" << endl;

    }

  

    virtual void fun3() {

        cout << "CTest virtual fun3()" << endl;

    }

};

  

int main() {

  

    //cout << sizeof(CTest)<<endl;//sizeof(类)得到的是类对应的对象的大小

  

    //CTest tst;

    //cout << &tst<< "   " << &tst.m_a << endl;

  

    //CTest tst2;

    //tst2.fun2();

  
  

    //CTest* ptst = nullptr;

    //ptst->fun();//空指针对象调用普通函数，虽然可以但是不推荐这样使用

    //ptst->fun2();//空指针对象调用不了虚函数

  

    //手动模拟虚函数调用

    CTest* ptst2 = new CTest;

    int a=*(int*)ptst2;

  

    typedef void (*P_FUN)();

    P_FUN p_fun1=(P_FUN)((int*)a)[0];

    P_FUN p_fun2=(P_FUN)((int*)a)[1];

  
  

    (*p_fun1)();//CTest virtual fun2()

    (*p_fun2)();//CTest virtual fun3()

    return 0;

}

```

  

## 虚析构

  

```c++

#include <iostream>

using namespace std;

  

class CFather

{

public:

    CFather()

    {

        cout << "CFather构造" << endl;

    }

    virtual~CFather()

    {

        cout << "CFather析构" << endl;

    }

};

  

class CSon : public CFather

{

public:

    int* m_p=nullptr;

    CSon()

    {

        cout << "CSon构造" << endl;

    }

    ~CSon()//在编译器角度，和父类的名字是相同的。可写可不写virtual

    {

        cout << "CSon析构" << endl;

        if (m_p)

        {

            delete m_p;

            m_p = nullptr;

        }

    }

};

  

/*

父类指针指向子类对象：在回收空间时，子类的析构没有被执行，有可能（不是一定）会发生内存泄漏，

父类的指针有效范围为父类，只能调用父类的析构函数，

解决这个问题：虚析构

发生多态行为，最终调用的是子类的析构函数，回收对象时，其中包函数父类的成员，回收父类成员前，会调用父类的析构。

*/

  

int main()

{

    //CSon son;

  

    CFather* pFa = new CSon;

    //pFa->~CFather();//可以

    //pFa->~CSon();//报错

  

    //delete (CSon*)pFa;//可以正确析构，但是不是一种好的方法

  
  

    pFa->~CFather();//调用虚析构函数，且子类的析构函数重写了父类的析构，实现了多态最终调用的是子类析构

    pFa = nullptr;

  

    return 0;

}

```

  

### 问题/现象

  

　　父类指针指向子类对象：在回收空间时，子类的析构没有被执行，有可能（不是一定）会发生内存泄漏，

  

　　父类的指针有效范围为父类，只能调用父类的析构函数，

  

### 解决方法：虚析构

  

　　由于子类重写了父类的析构函数，发生多态行为，最终调用的是子类的析构函数，回收对象时，其中包函数父类的成员，回收父类成员前，会调用父类的析构。

  

## 纯虚函数

  

　　纯虚函数：格式 **类内** `virtual void fun() = 0;`

  

　　​     纯虚函数，子类必须重写。只在父类声明，不需实现

  

　　包含纯虚函数的类不能实例化，又叫**抽象类**

  

```c++

#include <iostream>

using namespace std;

  

class CFather//包含纯虚函数的类，不能实例化，又叫 抽象类

{

public:

    virtual void fun() = 0;//纯虚函数，子类必须重写。只在父类声明，不需实现

    virtual void fun1()

    {

        cout << "Father::fun()2" << endl;

    }

};

  

class CSon : public CFather//抽象类的派生类，又称 具体类

{

public:

    virtual void fun()

    {

        cout << "CSon::fun()" << endl;

    }

    virtual void fun1()

    {

  

        cout << "Son::Pfun()1" << endl;

    }

};

  
  
  

int main()

{

  

    CFather* pFa = new CSon;

    pFa->fun();

  

    //CFather fa;//包含纯虚函数的类不能实例化，叫抽象类

    return 0;

}

  
  

```

  

|类|必备条件|特点|

| --------| ----------------| --------------------------|

|抽象类|有纯虚函数|不能实例化、子类**必须重写**纯虚函数|

|具体类|不能有纯虚函数|可以实例化|

  

### 多态缺点：

  

1. 效率：调用虚函数效率低。

2. 空间：虚函数指针占用空间，多个对象会有多个虚函数指针，虚函数列表会随若继承的层级递增虚表大小只增不减。

3. 安全：类中的私有的函数，不能为虚函数，否则会有安全隐忠。

  

# 06分文件编写

  

## 头文件和源文件的区别

  

　　1.使用区别：  

头文件：变量、函数 的声明，类的定义，宏的定义...  

源文件：变量的定义，函数定义实现，类中成员函数的定义实现，

  

## 注意事项

  

1. 声明变量`extern int c;   //声明变量`

2. 函数声明 `void fun();   //函数的声明`

3. 构造、析构的声明

  

   ```c++

   CTest();   //构造的声明

   ~CTest();  //析构的声明

   ```

4. 静态变量类外初始化，在.cpp文件中

5. 类成员函数在.cpp文件中定义，含·函数名前加**类名作用域**

6. 常量在源文件中的构造函数初始化参数列表中进行初始化

  

   ```c++

   CTest::CTest():m_a(5), m_b(20){  //常量在源文件中的构造函数初始化参数列表中进行初始化

    cout << "CTest()   " << m_a << endl;

    m_a = 10;

    cout << "CTest()   " << m_a << endl;

   }

   ```

7. static、virtual定义的时候关键字去掉

8. const定义的时候保留

9. 类模板

   类模板是泛型，与常规的不同，在编写的时候，不要分开。

  

## 头文件重复包含

  

　　例如：

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662109123858.png)

  

　　BB.h和CC.h都包含的AA.h，main函数有都包含了BB.h和CC.h，就会出现AA.重复包含的问题

  

### 解决方案1

  

　　在AA.h第一行加一句

  

　　`#pragma once`

  

　　#pragma once: 直接和编译器沟通，告诉编译器当前的头文件在其他源文件中，只包含一次，

直接和编译器沟通 效率高，代码编译的速度快，不需要考虑宏重名的问题

  

### 解决方案2

  

　　基于宏的逻辑判断，编译的速度慢，有一定的概率，宏的名字会重复，导致程序错误。

  

```c++

#ifndef   __宏__   //判断当前宏是否定义，如果没定义的话,就定义宏#define

#define   __宏__

  

...我的代码...

  

#endif  //__宏

```

  

# 07程序生成过程

  

## 程序生成过程（4个阶段）：

  

### 预处理：

  

　　源代码文件 main.cpp -> main.i 预处理后的文件

  

　　1.#include   头文件的展开  

2.删除注释  

3.#define 宏的替换。  

4.#ifndef ,#ifdef ,#else #elif  #if  #endif...等预处理指令

  

### 编译阶段：

  

　　将预处理后的文件进一步处理，生成汇编文件，包含汇编代码，  main.i  ->  main.asm(汇编文件)

  

　　对代码进行 语法分析、语义分析、词法分析 和 优化

  

### 汇编阶段：

  

　　将上一步生成的汇编文件，按照汇编代码一条一条生成目标机器指令，main.asm->main.obj(目标机器文件(二进制文件))

  

### 链接阶段：

  

　　通过链接器将多个目标文件（.obj）和库文件 链接整合到一起，生成可执行程序（.exe（二进制文件））

  

## 编译期：

  

　　将源代码文件交由编译器，编译、生成，最终生成可执行文件的过程。

  

## 运行期：

  

　　将可执行文件交由操作系统运行，直到程序退出的过程。

  

　　类编译期的概念，包括 访问修饰符 和 作用域，属于编译期的概念，

对象（类的一个实例化）运行期的概念，包括指针，引用等

  

## 细节

  

```c++

#include<iostream>

using namespace std;

  

/*

* 程序生成过程（4个阶段）：

预处理：源代码文件 main.cpp -> main.i 预处理后的文件

1.#include   头文件的展开

2.删除注释

3.#define 宏的替换。

4.#ifndef ,#ifdef ,#else #elif  #if  #endif...等预处理指令

  

编译阶段：将预处理后的文件进一步处理，生成汇编文件，包含汇编代码，  main.i  ->  main.asm(汇编文件)

对代码进行 语法分析、语义分析、词法分析 和 优化

  

汇编阶段：将上一步生成的汇编文件，按照汇编代码一条一条生成目标机器指令，main.asm->main.obj(目标机器文件(二进制文件))

  
  

链接阶段：通过链接器将多个目标文件（.obj）和库文件 链接整合到一起，生成可执行程序（.exe（二进制文件））

  
  

编译期：将源代码文件交由编译器，编译、生成，最终生成可执行文件的过程。

  

运行期：将可执行文件交由操作系统运行，直到程序退出的过程。

  

类编译期的概念，包括 访问修饰符 和 作用域，属于编译期的概念，

对象（类的一个实例化）运行期的概念，包括指针，引用等

  

*/

  

class CFather {

public:

    virtual void fun() {

        cout << "CFather::fun" << endl;

    }

};

  
  

char arr[20] = { 0 };

  

class CSon:public CFather {

private:  //编译期的限制，多态是运行期多态，所以限制不住，能调用

    virtual void fun() {

        cout << "CSon::fun" << endl;

    }

private:

    void fun2() {

        cout << "CSon::fun2" << endl;

    }

  

public:

    static void GetFun2() {

        printf("%p  %d\n",&CSon::fun2, &CSon::fun2);

  

        sprintf_s(arr,"%d", &CSon::fun2);

        cout << arr << endl;

    }

};

  

union AA {

    int a;

    void (*p_fun)();

}aa;

  
  

int main() {

  

    /*const bool a = true;   //优化的例子

    if (a) {

        cout << "aa" << endl;

    }*/

  

//

//  //编译期确定

//#if __cplusplus

//#define A   10

//#else

//#define A   20

//#endif //__cplusplus

//

//  int a = A;

//  cout << a << endl;

//

//

//  //运行期确定

//  int b = 0;

//  cin >> b;

//  if (b == 10) {

//      cout << "bbb" << endl;

//  }

//  else {

//      cout << "aaa" << endl;

//  }

//

//  //-------------------------------------

//  //编译期错误

//  //int len = 10;   //error C2131: 表达式的计算结果不是常数

    //int arr[len] = { 0 };

//  //const int len = 9999999999999;

//  //int arr[len] = { 0 };  //error C2148: 数组的总大小不得超过 0x7fffffff 字节

//

//  //运行期错误

//  //int l = 9999999999999;

//  int l = 9;

//  int * p = new int[l];

//  //p[20] = 0;  //数组越界，运行期错误

//

//  cout << "//---------------------------" << endl;

//  CFather* pFa = new CSon;

//  pFa->fun();   //CSon::fun

  
  

    //----------------------------

    CSon::GetFun2();

  

    aa.a = atoi(arr);   //将十进制字符串转成数字

    cout << aa.a << endl;

    (*aa.p_fun)();

  

    return 0;

}

```

  

## 注意

  

### 宏是编译期

  

### 变量开数组、数组过大都是编译期

  

### 数组越界是运行期

  

### 访问修饰符是编译期的限制，多态是运行期多态，所以限制不住，能调用

  

# 08宏和内联函数

  

## 宏

  

```c++

#pragma once

  

//宏替换，发生在预处理期

#define AA 10

  

/* \：反斜杠，链接当前行和下一行，最后一行一般不加，反斜杠后面什么也不加

*

*/

#define BB for (int i = 0; i < AA; i++)\

    {\

    cout << i << endl;\

    }

extern int a;

  
  

//带参数的宏

#define CC(COUNT)\

    for (int i = 0; i < COUNT; i++)\

    {\

    cout << i << " ";\

    }

  

#define DD(A,B) A*B

  

#define EE(A,B) (A)*(B)

  

#define FF(A,B) ((A)*(B))

  
  

// #A  将转换为字符串，相当于在外面加 双引号

#define HH(A) #A    

  

//将参数转换为字符，相当于加 单引号

#define JJ(A)  #@A

  

//链接作用

#define KK() int a##b=10;

//可以用来定义 多个相似的类

```

  

### 特点

  

　　宏替换，**发生在预处理期**

  

　　宏定义时需要跨行时：**\：反斜杠**，链接当前行和下一行，最后一行一般不加，反斜杠后面什么也不加

  

　　宏可以带参数

  

　　但是宏的参数不会进行运算求解，例如

  

　　`a = DD(2 + 3, 4);`宏只是单纯的替换  会替换成 2+3*4

  

　　**所以需要在宏中加()，控制优先级**

  

### 功能

  

1. #A  将转换为字符串，相当于在外面加 双引号

   #define HH(A) #A

2. 将参数转换为字符，相当于加 单引号

   #define JJ(A)  #@A

3. 链接作用，可以用来定义 多个相似的类  

   #define KK() int a##b=10

4. #undef AA      AA宏的作用范围到此为止

  

# 09运算符重载

  

```c++

#include<iostream>

using namespace std;

  

/*

重载操作符：本质上是一个比较特殊的函数，函数名operator后接要重载的操作符，

参数要根据操作符的使用规则来，与使用时的类型、顺序、数量要保持一致。

一般要有返回类型，为了和后续的操作符继续去操作。

告诉编译器当遇到这个操作符时，应当调用该函数来实现一个操作符的功能，是对原来的操作的功能的扩展

  

*/

  

/*

  

类内：作为类成员函数，有隐藏的this指针作为做第一个参数，省略了一个参数，类对象应当匹配this。

类外：类外：作为全局的重载操作符函数，没有隐藏的ths指针参数，会比类内的重载操作符函数多一个参数，且参数的顺序不是固定的，可以进行调整，

注意是否与类内的重载操作符函数产生歧义。

*/

class CTest

{

public:

    int m_a;

    CTest()

    {

        m_a = 10;

    }

  

    //operator  重载 操作符的关键字

    //重载函数：返回类型 operator 后接要重载的操作符

    int operator+(/*CTest * const this */int a)

    {

        return this->m_a + a;

    }

    int operator+=(/*CTest * const this */int a)

    {

        return this->m_a += a;

    }

  

    int operator=(int a)

    {

        this->m_a = a;

        return m_a;

    }

};

  
  

int main()

{

    CTest c1;

    int a = c1 + 20;

    cout << a<<endl;

  

    int b=0;

  

    c1 += 100;

    cout << c1.m_a << endl;

  

    cout << b << endl;

  

    CTest c2;

    c2 = c1 + 200;

    cout << c2.m_a << endl;;

  

    c2.operator+=(12);

    cout << c2.m_a << endl;//当成函数使用，不推荐

  

    return 0;

}

  

```

  

## 重载操作符

  

　　operator  重载 操作符的关键字

  

　　本质上是一个比较特殊的函数，函数名 operator后接要重载的操作符，

  

　　参数要根据操作符的使用规则来，与使用时的类型、顺序、数量要保持一致。一般要有返回类型，为了和后续的操作符继续去操作。

告诉编译器当遇到这个操作符时，应当调用该函数来实现一个操作符的功能，是对原来的操作的功能的扩展

  

　　重载函数：`返回类型 operator 后接要重载的操作符`

  

　　类内：作为类成员函数，有隐藏的this指针作为做第一个参数，省略了一个参数，类对象应当匹配this。  

类外：作为全局的重载操作符函数，没有隐藏的ths指针参数，会比类内的重载操作符函数多一个参数，且参数的顺序不是固定的，可以进行调整，  

注意是否与类内的重载操作符函数产生歧义。

  

## 注意

  

### 使用限制

  

1. 重载操作符函数不能改变操作符的使用规则，原来几个操作数，重载之后还是几个

2. 重载操作符函数不能有默认值

3. 重载操作符不能改变操作符的优先级和结合性

4. =   []   ()   ->   操作符只能在类内重载

  

    这个不允许在类外重载  

    `int operator=(int a, CTest& tst)

    {

    }`​

5. sizeof  ?:   .  .*     ::   不能重载

6. 对应同一个重载操作符函数参数不同，可能就代表不同的函数，例如  *可能是乘法、间接引用，

7. 必须制定一个结构体、类等自定义的类型

8. 不允许对运算符重定义原本就有的功能，<u>运算符重载是增加功能而不是重写原来的功能</u>

  

### 情况应对

  

1. 重载左++和右++的时候，右++需要加一个参数int。这个参数只是用来区分

2. 与类内的产生歧义，解决方法1、注释掉一个；2、加作用域运算符

  

## 类型转换函数

  

　　类型转换函数的作用/使用

  

```cpp

#include<iostream>

using namespace std;

  

/*

重载操作符和类型转换函数同时存在时，重载操作符优先级高

*/

  

class CTest

{

public:

    int m_a;

    CTest()

    {

        m_a = 10;

    }

    //类型转换函数，函数名  operator  后加类型 ，无参数，无返回类型

    operator int()

    {

        return m_a;//但是必须写一个返回

    }

    int operator+(int a)//优先级高

    {

        return this->m_a + a;

    }

  

};

  

int main()

{

  
  

    int a = 0;

    CTest tst;

    a = *(int*)&tst;

    cout << a << endl;//10

  

    tst.m_a = 20;

    a = tst;

    cout << a << endl;//20

  

}

```

  

　　![](https://liuhao-aliyun-oss.oss-cn-beijing.aliyuncs.com/1662206882158.png)​

  

　　重载操作符和类型转换函数同时存在时，重载操作符优先级高

  

## 运算符重载的应用——对链表的重构

  

```cpp

#include<iostream>

using namespace std;

  
  
  

struct Node {

public:

    int val;

    Node* pNext;

    Node(int v) {   //构造函数

        val = v;

        pNext = nullptr;

    }

};

  
  

class CMyIterator {

public:

    Node* m_pTemp;

    CMyIterator(Node* pNode) :m_pTemp(pNode) {

        //m_pTemp = pNode;

    }

    Node* operator=(Node* pNode) {

        m_pTemp = pNode;

        return m_pTemp;

    }

    bool operator==(Node* pNode) {

        return m_pTemp == pNode;

    }

    bool operator!=(Node* pNode) {

        return m_pTemp != pNode;

    }

    int operator*() {

        return m_pTemp ? m_pTemp->val : -1;

    }

    Node* operator++() {

        m_pTemp = m_pTemp->pNext;

        return m_pTemp;

    }

    Node* operator++(int) {

        Node* p = m_pTemp;  //标记加之前的

        m_pTemp = m_pTemp->pNext;

        return p;

    }

    operator bool() {

        return m_pTemp;

    }

};

  

class CMyList {

public:

    //void ShowList() {

    //  Node* pTemp = m_pHead;  //标记头，初始化

    //  pTemp = m_pHead;   //赋值  operator=

    //  while (pTemp) {    //operator == operator!= operator bool

    //      cout << pTemp->val << "   ";  //*pTemp    operator*

    //      pTemp = pTemp->pNext;  //pTemp++   operator++

    //  }

    //  cout << endl;

    //}

    void ShowList() {

        CMyIterator ite = m_pHead;   // Node* pTemp = m_pHead;  //标记头，初始化

        ite = m_pHead;               //pTemp = m_pHead;   //赋值  operator=

        while (ite) {//while (ite != nullptr){      //while (pTemp) {    //operator == operator!= operator bool

            cout << *ite << "    ";  //cout << pTemp->val << "   ";  //*pTemp    operator*

            ite++;                   //pTemp = pTemp->pNext;  //pTemp++   operator++

        }

        cout << endl;

    }

  

public:

    Node* m_pHead; //头尾指针

    Node* m_pEnd;

    int   m_nLen;   //链表长度

public:

    CMyList() {

        m_pHead = nullptr;

        m_pEnd = nullptr;

        m_nLen = 0;

    }

    ~CMyList() {

        Node* pTemp = nullptr;

        while (m_pHead) {

            pTemp = m_pHead;   //标记当前头结点

  

            m_pHead = m_pHead->pNext;

            delete pTemp;

        }

        m_pHead = nullptr;

        m_pEnd = nullptr;

        m_nLen = 0;

    }

public:

    void PushBack(int v) {

        //创建一个结点

        Node* pNode = new Node(v);   //匹配带参数的构造函数

  

        if (m_pHead) {   //非空链表

            m_pEnd->pNext = pNode;

            //m_pEnd = m_pEnd->pNext;

            //m_pEnd = pNode;

        }

        else {  //空链表

            m_pHead = pNode;

        }

        m_pEnd = pNode;

        ++m_nLen;   //长度增加

    }

  

    void PopFront() {

        if (m_pHead) {  //非空链表

  

            Node* pTemp = m_pHead;  //先标记头

            if (m_pHead == m_pEnd) {  //只有一个结点

                m_pHead = nullptr;

                m_pEnd = nullptr;

            }

            else {

                m_pHead = m_pHead->pNext;   //头结点向后移动

            }

  

            delete pTemp;   //删除标记的节点

            pTemp = nullptr;

  

            --m_nLen;   //长度减少

        }

    }

  

    int GetLen() {

        return m_nLen;

    }

};

  
  
  
  

int main() {

  

    CMyList myList;

    myList.PushBack(1);

    myList.PushBack(2);

    myList.PushBack(3);

    myList.PushBack(4);

    cout << "len = " << myList.GetLen() << endl;

    myList.ShowList();   //遍历

  
  

    myList.PopFront();

    myList.PopFront();

    cout << "len = " << myList.GetLen() << endl;

    myList.ShowList();   //遍历

  
  
  
  

    return 0;

}

```

  

# 10构造函数中的细节

  

## 拷贝构造函数

  

　　((20220924142546-3ofi840 '拷贝构造函数operator=-科林'))

  

### 定义

  

　　拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用。

  

```c++

class 类名

{ public : 类名（形参）；//构造函数

                类名（类名 &对象名）；//拷贝构造函数 ...

}；

//拷贝构造函数 ...

类名::类（类名 &对象名）//拷贝构造函数的实现

{ 函数体 }

如：

Box∷Box(const Box& b)

{

    height=b.height;

    width=b.width;

    length=b.length;

}

```

  

　　复制构造函数也是**构造函数**，但它只有一个参数，这个参数是本类 的对象(不能是其他类的对象)，而且采用对象的**引用的形式**(一般约定 加const声明，使参数值不能改变，以免在调用此函数时因不慎而使对 象值被修改)。

  

　　如果用户自己未定义复制构造函数，则编译系统会自动提供一个默认的 复制构造函数，其作用只是简单地复制类中每个数据成员。（效果上是浅拷贝）

  

### 注意普通构造函数和复制构造函数的区别

  

1. 在形式上

  

```c++

类名(形参表列); //普通构造函数的声明，如Box(int h,int ,int en);

  

类名(类名& 对象名); //复制构造函数的声明，如Box(Box &b);

```

  

2. 在建立对象时，实参类型不同

  

　　系统会根据实参的类型决定调用普通构造函数或复制构造函数。

  

```c++

Box box1(12,15,16); //实参为整数，调用普通构造函数

  

Box box2(box1); //实参是对象名，调用复制构造函数

```

  

3. 调用时候不同

  

　　**普通构造函数**在程序中**建立对象时**被调用。

  

　　**复制构造函数**在用**已有对象复制一个新对象**时被调用

  

### 调用

  

　　普通构造函数在程序中建立对象时被调用。 复制构造函数在用已有对象复制一个新对象时被调用，在以下3 种情况下需要克隆对象：

  

1. 程序中需要新建立一个对象，并用另一个同类的对象对它初始化：

  

　　box2=box1//box2(box1)

  

2. 当函数的参数为类的对象时。在调用函数时需要将实参对象 完整地传递给形参，也就是需要建立一个实参的拷贝，这 就是按实参复制一个形参，系统是通过调用复制构造函数 来实现的，这样能保证形参具有和实参完全相同的值。==简言之：函数传值的形式传对象时，系统自动调用类的拷贝构造含函数 ​==

  

    如

  

```C++

void fun(Box b) //形参是类的对象

  

{  }

  

int main( )

  

{Box box1(12,15,18);

  

fun(box1); //实参是类的对象，调用函数时将复制一个新对象b

  

return 0;

  

}

```

  

3. 函数的返回值是类的对象。 在函数调用完毕将返回值带回函数调用处时。此时需要将函数中的对象 复制一个临时对象并传给该函数的调用处。如：

  

```c++

Box f( ) //函数f的类型为Box类类型

  

{ Box box1(12,15,18);

  

return box1; //返回值是Box类的对象

  

}

  

int main( ){

  

Box box2; //定义Box类的对象box2

  

box2=f( ); //调用f函数，返回Box类的临时对象，并将它赋值给box2

  

}

```

  

　　以上几种调用复制构造函数都是由编译系统自动实现的，不必由用户自 己去调用，只要知道在这些情况下需要调用复制构造函数就可以了。

  

　　‍

  

#### 调用拷贝构造函数的例子（Point类为例）

  

```C++

#include "iostream"

using namespace std;

  

//定义一个Point类

class Point{

public:

    Point(int xx=0,int yy=0):x(xx),y(yy){}     //构造函数

    ~Point(){ };                              //析构函数

    Point(const Point &p);                //复制构造函数

    int getX()const{return x;}

    int getY()const {return y;}

private:

    int x,y;//私有成员

  

};

  

Point::Point(const Point &p)

{

    x = p.x;

    y = p.y;

    cout << "Calling the copy constructor" <<endl;

  

}

//形参作为Point类对象的函数

void fun1(Point p)

{

    cout<< p.getX()<<endl;

  

}

  

//返回类的对象

Point fun2()

{

    Point a(1,2);

    return a;

}

  

int main()

{

    Point a(4);    //第一个对象A,该过程利用了重载，后面的y默认为0

Point b(a);      //此时调用copy构造函数；情况1，用a初始化b，第一次调用copy构造函数

cout << b.getX()<<endl;

  

fun1(b);  //此时调用copy构造函数；类的对象在函数中为实参，第二次调用copy构造函数

  

b = fun2();//此时调用copy构造函数；函数返回值为类的对象，第三次调用copy构造函数

cout << b.getX()<<endl;

return 0;

  

}

```

  

## 转换构造函数

  

### 定义

  

　　支持发生隐式类型转换的构造函数

  

### 特征

  

　　这种构造函数的特征，至少需要传入一个值进行赋值，一个以上则不行

  

### 功能

  

```sql

CTest tst4 = 100;

cout << tst4.m_a << endl;

```

  

### 禁止发生隐式类型转换

  

　　**explcit 关键字**

  

　　修饰构造函数，禁止发生隐式类型转换

  

## 在是声明一个类时，编译器会为我们提供的

  

　　空类中会有哪些默认的函数：

  

1. 默认的无参构造

2. 默认的析构函数

3. 默认的拷贝构造函数[^4]

4. 默认的((20220924142958-ua5rfql 'operator='))函数

  

　　‍

  

## 拷贝构造函数：

  

　　也是编译器默认给提供的一种构造函数，  函数原型 CTest(const CTest& )， 重点是& 引用，一定要加上，不加会有问题函数体代码为不空，形参中的对象成员给this对象成员依次初始化一旦我们手动重构了拷贝构造，编译器就不会提供了默认的拷贝构造了当用当前的类对象给另一个类对象去初始化时，会调用拷贝构造默认的拷贝构造函数他是一个**浅拷贝**，可能会有浅拷贝的问题

  

### 浅拷贝问题：

  

1.  两个指针指向了同一块内存，当其中一个对象回收这个内存后，另一个对象在回收内存就会出问题

2.  当通过其中一个对象修改了内存空间的值，另一个对象再使用就是修改之后的值了

  

### 解决浅拷贝：

  

　　**深拷贝**,手动重构构造函数，并且为拷贝的指针额外申请属于自己的空间  

函数参数为结构体、类类型，应当使用引用或指针，来避免浅拷贝的发生

  

```cpp

#include<iostream>

using namespace std;

  

class CTest {

public:

    int m_a;

    int* m_p;

    CTest() {

        m_a = 10;

        m_p = new int(20);  //申请额外的空间

    }

    //拷贝构造函数：也是编译器默认给提供的一种构造函数，  函数原型 CTest(const CTest& )， 重点是& 引用，一定要加上，不加会有问题

    //函数体代码为不空，形参中的对象成员给this对象成员依次初始化

    //一旦我们手动重构了拷贝构造，编译器就不会提供了默认的拷贝构造了

    // 当用当前的类对象给另一个类对象去初始化时，会调用拷贝构造

    // 默认的拷贝构造函数他是一个浅拷贝，可能会有浅拷贝的问题

    //浅拷贝问题：

    // 1. 两个指针指向了同一块内存，当其中一个对象回收这个内存后，另一个对象在回收内存就会出问题

    // 2. 当通过其中一个对象修改了内存空间的值，另一个对象再使用就是修改之后的值了

    //CTest(const CTest& tst):m_a(tst.m_a),m_p(tst.m_p) {

    //  cout << "CTest(const CTest& tst)" << endl;

    //}

    //解决浅拷贝的 问题，深拷贝,手动重构构造函数，并且为拷贝的指针额外申请属于自己的空间

    // 函数参数为结构体、类类型，应当使用引用或指针，来避免浅拷贝的发生

    CTest(const CTest& tst) :m_a(tst.m_a)/*, m_p(tst.m_p)*/ {

        cout << "CTest(const CTest& tst)" << endl;

        if (tst.m_p) {

            this->m_p = new int(*tst.m_p);  //new 空间

        }

        else {

            this->m_p = nullptr;

        }

    }

    //空类中也会提供一个 默认的operator=,  函数体代码不为空，形参中的对象成员给this对象成员依次赋值

    //一旦我们手动重构了operator=，编译器就不会提供了默认的operator=了

    //默认的  operator=  也是一个浅拷贝，也会有浅拷贝的问题。

    //解决：深拷贝

    /*CTest& operator=(const CTest& tst) {

        this->m_a = tst.m_a;

        this->m_p = tst.m_p;

        return *this;

    }*/

    //深拷贝

    CTest& operator=(const CTest& tst) {

        if (this != &tst) {  //判断是否是自己

            this->m_a = tst.m_a;

            //this->m_p = tst.m_p;

            if (tst.m_p) {

                if (this->m_p) {

                    *this->m_p = *tst.m_p;

                }

                else {

                    this->m_p = new int(*tst.m_p);

                }

            }

            else {

                if (this->m_p) {

                    delete this->m_p;

                }

                this->m_p = nullptr;

            }

        }

  

        return *this;

    }

  

    ~CTest() {

        if (m_p) {  //回收额外的空间

            delete m_p;

            m_p = nullptr;

        }

    }

};

  
  

void fun(CTest& tst) {    //尽量使用指针或者引用

    cout << *tst.m_p << endl;

}

  
  

int main() {

    //CTest tst;

  

    //CTest tst2(tst);   //手动重构之后，调用的就是自己写的拷贝构造函数了

    //cout << tst2.m_a << endl;  //10

  

    //-------------------------------------

    //CTest tst3;

  

    //CTest tst4(tst3);

    //cout << tst4.m_a << "    " << *tst4.m_p << endl;

  

    //*tst3.m_p = 100;

  

    //cout << *tst4.m_p << endl;

  

    //CTest tst5;

    //fun(tst5);

  

    //----------------------------------------------

    CTest tst6;

    CTest tst7;

    tst6.m_a = 20;

    tst7 = tst6;  //赋值

    cout << tst7.m_a << endl;

  

    tst7 = tst7;  //自己给自己赋值，

    //---------------------------------

    cout << *tst6.m_p << endl;

    *tst7.m_p = 100;

    cout << *tst6.m_p << endl;

  
  

    return 0;

}

  

/*

空类中会有哪些默认的函数：

默认的无参构造

默认的析构函数

默认的拷贝构造函数

默认的 operator= 函数

  

*/

```

  

### operator=

  

　　空类中也会提供一个 默认的operator=,  函数体代码不为空，形参中的对象成员给this对象成员依次赋值一旦我们手动重构了operator=，编译器就不会提供了默认的operator=了默认的  operator=  也是一个浅拷贝，也会有浅拷贝的问题。

  

### 解决：深拷贝

  

```cpp

//空类中也会提供一个 默认的operator=,  函数体代码不为空，形参中的对象成员给this对象成员依次赋值

    //一旦我们手动重构了operator=，编译器就不会提供了默认的operator=了

    //默认的  operator=  也是一个浅拷贝，也会有浅拷贝的问题。

    //解决：深拷贝

    /*CTest& operator=(const CTest& tst) {

        this->m_a = tst.m_a;

        this->m_p = tst.m_p;

        return *this;

    }*/

    //深拷贝

    CTest& operator=(const CTest& tst) {

        if (this != &tst) {  //判断是否是自己

            this->m_a = tst.m_a;

            //this->m_p = tst.m_p;

            if (tst.m_p) {

                if (this->m_p) {

                    *this->m_p = *tst.m_p;

                }

                else {

                    this->m_p = new int(*tst.m_p);

                }

            }

            else {

                if (this->m_p) {

                    delete this->m_p;

                }

                this->m_p = nullptr;

            }

        }

  

        return *this;

  

```

  

　　‍

  

[^1]: ### 9.5 const修饰指针

  

    const修饰指针有三种情况

  

    1. const修饰指针   --- 常量指针

    2. const修饰常量   --- 指针常量

    3. const即修饰指针，又修饰常量

  

    **示例：**

  

    ```c++

    int main() {

  

      int a = 10;

      int b = 10;

  

      //const修饰的是指针，指针指向可以改，指针指向的值不可以更改

      const int * p1 = &a;

      p1 = &b; //正确

      //*p1 = 100;  报错

  

      //const修饰的是常量，指针指向不可以改，指针指向的值可以更改

      int * const p2 = &a;

      //p2 = &b; //错误

      *p2 = 100; //正确

  

        //const既修饰指针又修饰常量

      const int * const p3 = &a;

      //p3 = &b; //错误

      //*p3 = 100; //错误

  

      system("pause");

  

      return 0;

    }

    ```

    > 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量

    >

  

    * *const int * p叫常量指针，*p的操作不可** （p- >也不可）

  

    **int * const p叫指针常量，p的操作不可**

  
  

[^2]: #### 命名空间

  
  

[^4]: ## 拷贝构造函数