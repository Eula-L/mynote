# 虚函数
当一个类中存在虚函数时，在定义对象的内存空间的首地址会多分配出一块内存，标识这块内存的 变量称之为[[虚函数指针]]﴾_ vfptr﴿，他是类型为 void**，是一个二级指针，他指向了一个数组，这个 数组我们称之为虚函数列表﴾vftable﴿，**虚函数指针同成员属性一样，是属于对象的**，只有定义对象 的时候才会存在，同样在构造函数的初始化参数列表中进行初始化（编译器默认完成），多个对象 中多个虚函数指针指向了同一个虚函数列表。
## 定义虚函数
被virtual修饰的函数
```cpp
virtual void show() 
{
	cout << "CFather::virtual void show()" << endl;
}
```
## 调用流程
1. 找到对象内存空间首地址指针大小的一块空间(_ vfptr）
2. 通过它间接引用 找到虚函数列表（数组），
3. 通过下标定位匹配对应的虚函数地址，在通过这个地址调用虚函数。
## 虚函数和普通函数的区别
1. 本质区别：函数调用流程不同
2. 效率不同：普通函数性能强，虚函数性能弱
3. 使用场景不同：虚函数可以实现多态，普通函数不能
# 虚函数列表
虚函数列表 他是一个数组，每个元素虽然是void* 类型，但实际上为虚函数指针，指向了具体的虚 函数。虚函数列表属于类的，在编译期就存在，只有一份被多个对象共享，虽然在编译期就存在 了，但在没有对象（或空指针对象）的情况，无法调用虚函数，必须通过真实存在的对象调用。 虚函数调用流程：找到定义对象内存中的vfptr，通过该指针间接引用找到虚函数列表，在虚函数 列表地中找到其地址，匹配后调用真正的虚函数。
虚函数的调用流程相比普通函数而言复杂的多，这是他们的本质区别，除此之外使用场景也不
同， 虚函数主要用于实现多态，这一点是普通的函数无法做到的。
### 特点
1. 编译期存在，属于类，只有一份，为多个对象的虚函数所共用 
2. 存放类中虚函数的地址的空间
3. 按照类中声明顺序排布，以数组的形式呈现，每个元素为虚函数的地址
![[单个类的虚函数列表.png]]
```cpp
#include<iostream>
using namespace std;
class CTest {
public:
	int m_a;
	void fun() {//函数属于类，而不属于对象
		cout << "CTest fun()" << endl;
	}
	/*_vfptr虚函数指针
	 存在一个虚函数指针，类型为void**
	 属于对象的二级指针，在对象内存空间的首地址
	定义多个对象，虚函数指针会存在多份，但是多个对象的虚函数指针指向的是同一个地址（虚函数列表）
	_vfptr 是编译期 默认给加到类中的 成员属性，在定义对象时，在构造的初始化参数列表中由编译器自动进行初始化，指向虚函数列表
	*/
	
	/*虚函数列表
	编译期存在，属于类，只有一份，为多个对象的虚函数所共用
	存放类中虚函数的地址的空间
	按照类中声明顺序排布，以数组的形式呈现，每个元素为虚函数的地址
	*/


	/*虚函数的调用流程
	1. 找到对象内存空间首地址指针大小的一块空间（_vfptr），
	2. 通过它间接引用 找到虚函数列表（数组），
	3. 通过下标定位匹配对应的虚函数地址，在通过这个地址调用虚函数。
	*/

	/*普通函数的调用流程
	通过函数名（即为函数的入口地址），然后直接跳转执行函数
	*/

	/*虚函数和普通函数的区别
	1. 本质区别：函数调用流程不同
	2. 效率不同：普通函数性能强，虚函数性能弱
	3. 使用场景不同：虚函数可以实现多态，普通函数不能
	*/

	virtual void fun2() {
		cout << "CTest virtual fun2()" << endl;
	}

	virtual void fun3() {
		cout << "CTest virtual fun3()" << endl;
	}
};

int main() {

	//cout << sizeof(CTest)<<endl;//sizeof(类)得到的是类对应的对象的大小

	//CTest tst;
	//cout << &tst<< "   " << &tst.m_a << endl;

	//CTest tst2;
	//tst2.fun2();


	//CTest* ptst = nullptr;
	//ptst->fun();//空指针对象调用普通函数，虽然可以但是不推荐这样使用
	//ptst->fun2();//空指针对象调用不了虚函数

	//手动模拟虚函数调用
	CTest* ptst2 = new CTest;
	int a=*(int*)ptst2;

	typedef void (*P_FUN)();
	P_FUN p_fun1=(P_FUN)((int*)a)[0];
	P_FUN p_fun2=(P_FUN)((int*)a)[1];


	(*p_fun1)();//CTest virtual fun2()
	(*p_fun2)();//CTest virtual fun3()
	return 0;
}
```